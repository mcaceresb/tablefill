{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"tablefill Automatically update LaTeX and LyX tables using a placeholder system. Quickstart pip install git+https://github.com/mcaceresb/tablefill tablefill --help Documentation tablefill is a program that uses a generic placeholder system to fill LaTeX and LyX tables using formatted output from any programming language. The getting started gives a a basic example of how the system works. Sample workflow guides the user on how to automate LaTeX table updating. The usage section details the input required by tablefill , the format of the paceholders that are allowed, and documents the tablefill usage options. Last, we provide examples of how to generate the type of input required by tablefill in the sample programs page. Background The original idea for this workflow comes from GSLab . The original tablefill in particular was made to automatically update LyX files with Stata output. However, I expanded this system to be generic enough to work with any programming language and added several features. The workflow for the is as follows: Create a LaTeX or LyX document using placeholders in your tables. Label or tab each table appropriately. Print a matrix (or any array) to a delimited text file. The output is preceded by the tag of the table you want to fill, and the matrix or array's entries correspond to the placeholders. Run tablefill to update the placeholders in the template document. The original tablefill only worked with LyX and assumed the tables came from Stata (or Matlab). This project initially aimed to extend the system to work with LaTeX, but over time it re-wrote the entire code base and added several features: The input tables can be generated by any program, as long as they write missing values as blank, a dot, or NA (the \".\" and \"NA\" are exceptions made for Stata and R). The format is to print a tag on the line prior to the table, <tab:table_label> , and then print a tab-delimited table (typically a matrix, but it can be any flat array and have rows or varying length). For compatibility with scripts using GSLab's tablefill, the script can be run from the command line or imported as a python module. Installation pip install git+https://github.com/mcaceresb/tablefill tablefill --help This was created specifically to run in a server that only had Python 2.6 available. The function should be compatible with Python 2.6, Python 2.7, and Python 3.X without requiring the installation of any additional packages (the --numpy-syntax option is available if the function can successfully run import numpy ; however, numpy is not required for normal use). Features Several error and consistency checks Checks inputs are correct (names and type) Checks if input files exist Soft warning when placeholder outside proper environment Soft warning when placeholder in environment with no label Soft warning when placeholder in environment with unmatched label Soft warning when more placeholders than table entries Can fill LaTeX templates There can be several placeholders in one line However, there must be at most one table line per code line Environment must be a table environment, not tabular Placeholders can be either # or \\# (note the former is a special character in LaTeX so while the filled output will compile, the template will not). Labels in LaTeX can be anywhere in the table environment Can have several matches of the pattern in the same line Can be run from the command line directly or imported to a python script. Can choose whether to fill commented out lines. Adds placeholder modifiers % and ||; added placeholder type #*# Adding the % before closing a placeholder causes tablefill to interpret it as a percentage (i.e. multiplies the number by 100). Enclosing the contents of a placeholder in pipes, || , causes tablefill to take the absolute value of the input. The placeholder #*# causes the entry to be interpreted as a p-value. The user can specify the p-value levels and symbols to replace them with (anything that LaTeX will compile can be passed). Default is * 0.1, **0.05, ***0.01 . Basic LaTeX compilation via the --compile and/or --bibtex flags. Added XML-based ad-hoc table combination engine. The user can combine arbitrary entries of existing tables in the provided templates to create new tables. This is useful if generating new tables is costly. It is also useful to quote table statistics in a summary elsewhere in the text (the LaTeX engine can parse the placeholders as long as they are in a table environment, which can be regular text). Contributors The original idea for tablefill comes from GSLab 's tablefill . Kyle Barron made the project into a pip-installable package. License MIT","title":"Home"},{"location":"index.html#tablefill","text":"Automatically update LaTeX and LyX tables using a placeholder system. Quickstart pip install git+https://github.com/mcaceresb/tablefill tablefill --help","title":"tablefill"},{"location":"index.html#documentation","text":"tablefill is a program that uses a generic placeholder system to fill LaTeX and LyX tables using formatted output from any programming language. The getting started gives a a basic example of how the system works. Sample workflow guides the user on how to automate LaTeX table updating. The usage section details the input required by tablefill , the format of the paceholders that are allowed, and documents the tablefill usage options. Last, we provide examples of how to generate the type of input required by tablefill in the sample programs page.","title":"Documentation"},{"location":"index.html#background","text":"The original idea for this workflow comes from GSLab . The original tablefill in particular was made to automatically update LyX files with Stata output. However, I expanded this system to be generic enough to work with any programming language and added several features. The workflow for the is as follows: Create a LaTeX or LyX document using placeholders in your tables. Label or tab each table appropriately. Print a matrix (or any array) to a delimited text file. The output is preceded by the tag of the table you want to fill, and the matrix or array's entries correspond to the placeholders. Run tablefill to update the placeholders in the template document. The original tablefill only worked with LyX and assumed the tables came from Stata (or Matlab). This project initially aimed to extend the system to work with LaTeX, but over time it re-wrote the entire code base and added several features: The input tables can be generated by any program, as long as they write missing values as blank, a dot, or NA (the \".\" and \"NA\" are exceptions made for Stata and R). The format is to print a tag on the line prior to the table, <tab:table_label> , and then print a tab-delimited table (typically a matrix, but it can be any flat array and have rows or varying length). For compatibility with scripts using GSLab's tablefill, the script can be run from the command line or imported as a python module.","title":"Background"},{"location":"index.html#installation","text":"pip install git+https://github.com/mcaceresb/tablefill tablefill --help This was created specifically to run in a server that only had Python 2.6 available. The function should be compatible with Python 2.6, Python 2.7, and Python 3.X without requiring the installation of any additional packages (the --numpy-syntax option is available if the function can successfully run import numpy ; however, numpy is not required for normal use).","title":"Installation"},{"location":"index.html#features","text":"Several error and consistency checks Checks inputs are correct (names and type) Checks if input files exist Soft warning when placeholder outside proper environment Soft warning when placeholder in environment with no label Soft warning when placeholder in environment with unmatched label Soft warning when more placeholders than table entries Can fill LaTeX templates There can be several placeholders in one line However, there must be at most one table line per code line Environment must be a table environment, not tabular Placeholders can be either # or \\# (note the former is a special character in LaTeX so while the filled output will compile, the template will not). Labels in LaTeX can be anywhere in the table environment Can have several matches of the pattern in the same line Can be run from the command line directly or imported to a python script. Can choose whether to fill commented out lines. Adds placeholder modifiers % and ||; added placeholder type #*# Adding the % before closing a placeholder causes tablefill to interpret it as a percentage (i.e. multiplies the number by 100). Enclosing the contents of a placeholder in pipes, || , causes tablefill to take the absolute value of the input. The placeholder #*# causes the entry to be interpreted as a p-value. The user can specify the p-value levels and symbols to replace them with (anything that LaTeX will compile can be passed). Default is * 0.1, **0.05, ***0.01 . Basic LaTeX compilation via the --compile and/or --bibtex flags. Added XML-based ad-hoc table combination engine. The user can combine arbitrary entries of existing tables in the provided templates to create new tables. This is useful if generating new tables is costly. It is also useful to quote table statistics in a summary elsewhere in the text (the LaTeX engine can parse the placeholders as long as they are in a table environment, which can be regular text).","title":"Features"},{"location":"index.html#contributors","text":"The original idea for tablefill comes from GSLab 's tablefill . Kyle Barron made the project into a pip-installable package.","title":"Contributors"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"getting-started.html","text":"Getting Started You can use tablefill from the command line or from python. To install, run pip install git+https://github.com/mcaceresb/tablefill Then you can call tablefill via tablefill -i input1.tex [ input2.tex ... ] -o output.tex template.tex The section below shows a basic example of how tablefill works. See the sample workflow section for details on how to go from results in Stata/R/etc. to automated table production in LaTeX. Basic Example input1.txt contains the data used to fill the template. This file is generated your programming language of choice (e.g. Stata) with output from a regression, a table with summary statistics, etc. The entries must be tab-delimited and each section separated by a label of the format <tab:label> (see the sample programs for examples on how to do this on various programming languages): < tab : example > 1 1237 . 1234 1 2 2 2234 . 4 3 2 . 4 3 3 . 345345 2 2 . 456 4 2234 . 4 3 2 . 4 < tab : anotherExample > - 1 . 25 - 1 . 18 0 . 1447266 2 . 756 - 0 . 53 9 . 964426 e - 08 1 . 13 0 . 57235 0 . 02417291 template.tex contains the LaTeX file with placeholders corresponding to the data in input1.txt . The template should compile as is: \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes \\#\\#\\# & \\# 1, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 1, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } cc } Variables & Coef & (SE) \\\\ Variable 1 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ Variable 2 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ Variable 3 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } Note that each table environment is labeled, and the label corresponds to the set of results we want to fill that table with. Further note that the shape of the input matrices correspond to the number of placeholders in the table environment (the shape need not be the same; see the matrix input section for details). To fill the template, run tablefill -i input1.txt -o filled.tex template.tex This produces the file filled.tex : %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % This file was produced by 'tablefill.py' % Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.tex % Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input1.txt'] % To make changes, edit the input and template files. % % % DO NOT EDIT THIS FILE DIRECTLY. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\ Outcomes 1 & 1,237.1 & 1.0 & (2.0) \\ Outcomes 2 & 2,234 & 3.0 & (2.4) \\ Outcomes 3 & 3.3 & 2.0 & (2.5) \\ Outcomes 4 & 2,234 & 3.0 & (2.4) \\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } c } Variables & Coef & (SE) \\ Variable 1 & -1.25 (-1.18) \\ Variable 2 & 2.76 (-0.53)*** \\ Variable 3 & 1.13 (0.57)** \\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } The placeholders in tab:example were replaced with the entries right under <tab:example> in the file input1.txt , and similarly with tab:anotherExample . tablefill assumes that the input ends when the next placeholder starts or at the end of the file. Note that the entries have been formatted based on the directions passed by the placeholders. Explanation The way tablefill operates is: Per line, the program searches for a \\begin{table} statement.. If found, it searches for a \\label{tab:(.+)} BEFORE an \\end{table} . If a label is found, it searches the input files for a label a match. Find all occurrences of placeholders (note that in LaTeX, # is a special character, so tablefill will match both # and \\# as part of a placeholder construct; this is so that templates can be compiled before using tablefill to fill in the values): Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. |###| Get the absolute value of the number. Repeat 3 and 4 until reaching \\end{table} Move on to next table: Repeat 1 to 5 until reaching the end of the document. We can see this in the example above: \\#\\#\\# was replaced as is. \\#0\\# , \\#1\\# , and \\#2\\# were rounded to 0, 1, and 2 significant digits. \\#0,\\# were comma-delimited. \\#*\\# were replaced with significance stars.","title":"Getting Started"},{"location":"getting-started.html#getting-started","text":"You can use tablefill from the command line or from python. To install, run pip install git+https://github.com/mcaceresb/tablefill Then you can call tablefill via tablefill -i input1.tex [ input2.tex ... ] -o output.tex template.tex The section below shows a basic example of how tablefill works. See the sample workflow section for details on how to go from results in Stata/R/etc. to automated table production in LaTeX.","title":"Getting Started"},{"location":"getting-started.html#basic-example","text":"input1.txt contains the data used to fill the template. This file is generated your programming language of choice (e.g. Stata) with output from a regression, a table with summary statistics, etc. The entries must be tab-delimited and each section separated by a label of the format <tab:label> (see the sample programs for examples on how to do this on various programming languages): < tab : example > 1 1237 . 1234 1 2 2 2234 . 4 3 2 . 4 3 3 . 345345 2 2 . 456 4 2234 . 4 3 2 . 4 < tab : anotherExample > - 1 . 25 - 1 . 18 0 . 1447266 2 . 756 - 0 . 53 9 . 964426 e - 08 1 . 13 0 . 57235 0 . 02417291 template.tex contains the LaTeX file with placeholders corresponding to the data in input1.txt . The template should compile as is: \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes \\#\\#\\# & \\# 1, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 1, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 1 \\# ) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } cc } Variables & Coef & (SE) \\\\ Variable 1 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ Variable 2 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ Variable 3 & \\# 2 \\# ( \\# 2 \\# ) \\#*\\# \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } Note that each table environment is labeled, and the label corresponds to the set of results we want to fill that table with. Further note that the shape of the input matrices correspond to the number of placeholders in the table environment (the shape need not be the same; see the matrix input section for details). To fill the template, run tablefill -i input1.txt -o filled.tex template.tex This produces the file filled.tex : %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % This file was produced by 'tablefill.py' % Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.tex % Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input1.txt'] % To make changes, edit the input and template files. % % % DO NOT EDIT THIS FILE DIRECTLY. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\ Outcomes 1 & 1,237.1 & 1.0 & (2.0) \\ Outcomes 2 & 2,234 & 3.0 & (2.4) \\ Outcomes 3 & 3.3 & 2.0 & (2.5) \\ Outcomes 4 & 2,234 & 3.0 & (2.4) \\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } c } Variables & Coef & (SE) \\ Variable 1 & -1.25 (-1.18) \\ Variable 2 & 2.76 (-0.53)*** \\ Variable 3 & 1.13 (0.57)** \\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } The placeholders in tab:example were replaced with the entries right under <tab:example> in the file input1.txt , and similarly with tab:anotherExample . tablefill assumes that the input ends when the next placeholder starts or at the end of the file. Note that the entries have been formatted based on the directions passed by the placeholders.","title":"Basic Example"},{"location":"getting-started.html#explanation","text":"The way tablefill operates is: Per line, the program searches for a \\begin{table} statement.. If found, it searches for a \\label{tab:(.+)} BEFORE an \\end{table} . If a label is found, it searches the input files for a label a match. Find all occurrences of placeholders (note that in LaTeX, # is a special character, so tablefill will match both # and \\# as part of a placeholder construct; this is so that templates can be compiled before using tablefill to fill in the values): Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. |###| Get the absolute value of the number. Repeat 3 and 4 until reaching \\end{table} Move on to next table: Repeat 1 to 5 until reaching the end of the document. We can see this in the example above: \\#\\#\\# was replaced as is. \\#0\\# , \\#1\\# , and \\#2\\# were rounded to 0, 1, and 2 significant digits. \\#0,\\# were comma-delimited. \\#*\\# were replaced with significance stars.","title":"Explanation"},{"location":"sample-programs.html","text":"Sample Programs Here we illustrate how to export a matrix into the preferred format of tablefill in several programming languages. R saveTable <- function ( outfile , tag , outmatrix ) { cat ( tag , sep = \"\\n\" , file = outfile , append = TRUE ) write.table ( outmatrix , file = outfile , sep = \"\\t\" , append = TRUE , quote = FALSE , col.names = FALSE , row.names = FALSE ) } saveTable ( \"test.txt\" , \"<tab:testR1>\" , matrix ( 1 : 4 , 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testR2>\" , matrix ( runif ( 4 ), 2 , 2 )) Stata capture program drop saveTable program saveTable version 13 syntax using / , tag(str) OUTMatrix(name) [fmt(str)] mata : saveTable() end capture mata : mata drop saveTable() mata : void function saveTable() { real scalar i, j, fh real matrix outmatrix outmatrix = st_matrix(st_local( \"outmatrix\" )) fmt = st_local( \"fmt\" ) if ( fmt == \"\" ) { fmt = \"%21.9f\" } fmt = \"\\t\" + fmt fh = fopen(st_local( \"using\" ), \"a\" ) fwrite(fh, sprintf( \"%s\\n\" , st_local( \"tag\" ))) for (i = 1 ; i <= rows(outmatrix); i ++ ) { for (j = 1 ; j <= cols(outmatrix); j ++ ) { fwrite(fh, sprintf(fmt, outmatrix[i, j])) } fwrite(fh, sprintf( \"\\n\" )) } fclose(fh) } end matrix test = ( 1 , 2 \\ 3 , 4 ) saveTable using \"test.txt\" , tag( \"<tab:testStata1>\" ) outmatrix(test) mata : st_matrix( \"test\" , runiform ( 2 , 2 )) saveTable using \"test.txt\" , tag( \"<tab:testStata2>\" ) outmat(test) Python from os import linesep import numpy as np def saveTable ( outfile , tag , outmatrix ): with open ( outfile , \"a\" ) as fh : fh . write ( tag ) fh . write ( linesep ) np . savetxt ( fh , outmatrix , delimiter = ' \\t ' ) saveTable ( \"test.txt\" , \"<tab:testPython1>\" , np . arange ( 4 ) . reshape ( 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testPython2>\" , np . random . uniform ( size = ( 2 , 2 ))) Julia using DelimitedFiles function saveTable ( outfile , tag , outmatrix ) open ( outfile , \"a\" ) do file write ( file , \" $ ( tag ) \\n \" ) writedlm ( file , outmatrix , \" \\t \" ) end end saveTable ( \"test.txt\" , \"<tab:testJulia1>\" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \"test.txt\" , \"<tab:testJulia2>\" , rand ( 2 , 2 )) Matlab Save saveTable.m with function saveTable ( outfile, tag, outmatrix ) fh = fopen ( outfile , \" a \" ); fprintf ( fh , '%s\\n' , tag ); fclose ( fh ); dlmwrite ( outfile , outmatrix , '-append' , 'delimiter' , '\\t' ); end Then run saveTable ( \" test . txt \" , \" < tab : testMatlab1 > \" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \" test . txt \" , \" < tab : testMatlab2 > \" , rand ( 2 , 2 ))","title":"Sample Programs"},{"location":"sample-programs.html#sample-programs","text":"Here we illustrate how to export a matrix into the preferred format of tablefill in several programming languages.","title":"Sample Programs"},{"location":"sample-programs.html#r","text":"saveTable <- function ( outfile , tag , outmatrix ) { cat ( tag , sep = \"\\n\" , file = outfile , append = TRUE ) write.table ( outmatrix , file = outfile , sep = \"\\t\" , append = TRUE , quote = FALSE , col.names = FALSE , row.names = FALSE ) } saveTable ( \"test.txt\" , \"<tab:testR1>\" , matrix ( 1 : 4 , 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testR2>\" , matrix ( runif ( 4 ), 2 , 2 ))","title":"R"},{"location":"sample-programs.html#stata","text":"capture program drop saveTable program saveTable version 13 syntax using / , tag(str) OUTMatrix(name) [fmt(str)] mata : saveTable() end capture mata : mata drop saveTable() mata : void function saveTable() { real scalar i, j, fh real matrix outmatrix outmatrix = st_matrix(st_local( \"outmatrix\" )) fmt = st_local( \"fmt\" ) if ( fmt == \"\" ) { fmt = \"%21.9f\" } fmt = \"\\t\" + fmt fh = fopen(st_local( \"using\" ), \"a\" ) fwrite(fh, sprintf( \"%s\\n\" , st_local( \"tag\" ))) for (i = 1 ; i <= rows(outmatrix); i ++ ) { for (j = 1 ; j <= cols(outmatrix); j ++ ) { fwrite(fh, sprintf(fmt, outmatrix[i, j])) } fwrite(fh, sprintf( \"\\n\" )) } fclose(fh) } end matrix test = ( 1 , 2 \\ 3 , 4 ) saveTable using \"test.txt\" , tag( \"<tab:testStata1>\" ) outmatrix(test) mata : st_matrix( \"test\" , runiform ( 2 , 2 )) saveTable using \"test.txt\" , tag( \"<tab:testStata2>\" ) outmat(test)","title":"Stata"},{"location":"sample-programs.html#python","text":"from os import linesep import numpy as np def saveTable ( outfile , tag , outmatrix ): with open ( outfile , \"a\" ) as fh : fh . write ( tag ) fh . write ( linesep ) np . savetxt ( fh , outmatrix , delimiter = ' \\t ' ) saveTable ( \"test.txt\" , \"<tab:testPython1>\" , np . arange ( 4 ) . reshape ( 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testPython2>\" , np . random . uniform ( size = ( 2 , 2 )))","title":"Python"},{"location":"sample-programs.html#julia","text":"using DelimitedFiles function saveTable ( outfile , tag , outmatrix ) open ( outfile , \"a\" ) do file write ( file , \" $ ( tag ) \\n \" ) writedlm ( file , outmatrix , \" \\t \" ) end end saveTable ( \"test.txt\" , \"<tab:testJulia1>\" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \"test.txt\" , \"<tab:testJulia2>\" , rand ( 2 , 2 ))","title":"Julia"},{"location":"sample-programs.html#matlab","text":"Save saveTable.m with function saveTable ( outfile, tag, outmatrix ) fh = fopen ( outfile , \" a \" ); fprintf ( fh , '%s\\n' , tag ); fclose ( fh ); dlmwrite ( outfile , outmatrix , '-append' , 'delimiter' , '\\t' ); end Then run saveTable ( \" test . txt \" , \" < tab : testMatlab1 > \" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \" test . txt \" , \" < tab : testMatlab2 > \" , rand ( 2 , 2 ))","title":"Matlab"},{"location":"sample-workflow.html","text":"Sample Workflow Warning This page is under construction This section details an example of how to go from a set of results in Stata, R, etc. to automated table production in LaTeX. For this example we will use Stata, but this can be imitated in any programming language. LaTeX Make template. Stata Make results. Tablefill Fill template. Automation Automatically update results.","title":"Sample Workflow"},{"location":"sample-workflow.html#sample-workflow","text":"Warning This page is under construction This section details an example of how to go from a set of results in Stata, R, etc. to automated table production in LaTeX. For this example we will use Stata, but this can be imitated in any programming language.","title":"Sample Workflow"},{"location":"sample-workflow.html#latex","text":"Make template.","title":"LaTeX"},{"location":"sample-workflow.html#stata","text":"Make results.","title":"Stata"},{"location":"sample-workflow.html#tablefill","text":"Fill template.","title":"Tablefill"},{"location":"sample-workflow.html#automation","text":"Automatically update results.","title":"Automation"},{"location":"usage/02matrix-input.html","text":"Matrix Shapes Warning This page is under construction Input files must be tab-delimited rows of numbers or characters, preceded by <label> . The numbers can be arbitrarily long, can be negative, and can also be in scientific notation. < tab : Test > 1 2 3 2 3 1 3 1 2 The rows do not need to be of equal length. < tab : FunnyMat > 1 2 3 23 2 2 3 3 1 2 2 1 Completely blank (no tab) lines are ignored. If a \"cell\" is merely \".\", \"[space]\", or \"NA\" then it is treated as missing. That is, in the program: < tab : Test > 1 2 3 2 . 1 3 3 1 2 is equivalent to: < tab : Test > 1 2 3 2 1 3 3 1 2 This feature is useful as several languages outputs missing values as NA, blank, or \".\". Last, tablefill understands scientific notation of the form: [numbers].[numbers]e(+/-)[numbers] < tab : TestScientific > 23 . 2389 e + 23 - 2 . 23 e - 2 - 0 . 922 e + 3","title":"Matrix Input"},{"location":"usage/02matrix-input.html#matrix-shapes","text":"Warning This page is under construction Input files must be tab-delimited rows of numbers or characters, preceded by <label> . The numbers can be arbitrarily long, can be negative, and can also be in scientific notation. < tab : Test > 1 2 3 2 3 1 3 1 2 The rows do not need to be of equal length. < tab : FunnyMat > 1 2 3 23 2 2 3 3 1 2 2 1 Completely blank (no tab) lines are ignored. If a \"cell\" is merely \".\", \"[space]\", or \"NA\" then it is treated as missing. That is, in the program: < tab : Test > 1 2 3 2 . 1 3 3 1 2 is equivalent to: < tab : Test > 1 2 3 2 1 3 3 1 2 This feature is useful as several languages outputs missing values as NA, blank, or \".\". Last, tablefill understands scientific notation of the form: [numbers].[numbers]e(+/-)[numbers] < tab : TestScientific > 23 . 2389 e + 23 - 2 . 23 e - 2 - 0 . 922 e + 3","title":"Matrix Shapes"},{"location":"usage/03placeholders.html","text":"Placeholders Warning This page is under construction The template placeholders determine where the numbers from the input files are and how they will be displayed. Every table in the template file (if it is to be filled) must appear within a table environment. There can be several tabular environments within the table environment, but only ONE label per table environment. While label names may appear more than once in both the template and input files, only the last instance of the label in the input files will be used. This because of the way the system is set up: The last label in the input file should be the most up to date version of that table. In the template file, repeated labels are filled with the same data. By design, labels are NOT case-sensitive. Placeholders The values in the template file are parsed as follows: Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. |###| Get the absolute value of the number. Consider the following examples abc + ### = abc 2309 . 2093 + ### = 2309 . 2093 2309 . 2093 + # 4 # = 2309 . 2093 2309 . 2093 + # 5 # = 2309 . 20930 2309 . 2093 + # 20 # = 2309 . 20930000000000000000 2309 . 2093 + # 3 # = 2309 . 209 2309 . 2093 + # 2 # = 2309 . 21 2309 . 2093 + # 0 # = 2309 2309 . 2093 + # 0 , # = 2 , 309 - 2 . 23 e - 2 + # 2 # = - 0 . 0223 + # 2 # = - 0 . 02 - 2 . 23 e + 10 + # 7 , # = - 22300000000 + # 7 , # = - 22 , 300 , 000 , 000 . 000000 2309 . 2093 + ( # 2 # ) = ( 2309 . 21 ) 2309 . 2093 + # 2 #** = 2309 . 21 ** 2309 . 2093 + ab # 2 # cd = ab2309 . 21 cd . 2093 + # 1 %# = 20 . 9 - 2 . 23 e - 2 + |# 7 #| = - 0 . 0223 + |# 7 #| = 0 . 0223000 . 1309 + #*# = . 0639 + #*# = * . 0139 + #*# = ** . 0013 + #*# = *** Note that there can be ANYTHING around the pattern and the engine will only match the pattern. Further, in LaTeX, the # character must be escaped, so the engine also matches #. Consider: 3234 . 43241 + \\\\ beta Hi \\$ ( \\ # \\ # \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ ## \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # \\ ## ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( # \\ # \\ # ) \\ % = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ % 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ ### ) * \\ % = \\\\ beta Hi \\$ ( 3234 . 43241 ) * \\ % 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3 , 234 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3 , 234 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , #* = \\\\ beta Hi \\$ ( 3 , 234 * 3234 . 43241 + & \\\\ beta Hi \\$ ( # 0 , \\ #* = \\\\ beta Hi \\$ ( 3 , 234 * 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , #* = \\\\ beta Hi \\$ ( 3 , 234 * Matrices Simple Example Input: < tab : Test > 1 2 3 2 1 3 3 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 2 3 2 1 3 3 1 2 Missing Values Input: < tab : Test > 1 . 3 2 e - 5 1 3 . 023 . - 1 2 3 Template: \\ label { tab : test } ( \\ # \\ # \\ # ) & 2 & \\ # \\ # \\ # & \\\\\\\\ \\ # 3 \\ # & \\ # \\ # \\ # & \\ # 1 \\ # & \\\\\\\\ NA & \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } ( 1 ) 2 3 0 . 000 1 3 . 0 NA - 1 2 3 Important : Missing values in input and template need not line up. Input: < tab : Test > 1 . 3 2 e - 5 . 3 . 023 . - 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & abc \\\\\\\\ abc & \\ # 2 \\ # & \\ # 3 \\ # \\\\\\\\ NA & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 3 abc abc 0 . 00 3 . 023 NA - 1 2 Text Input: < tab : Test > 1 1 2 1 1 3 2 - 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ abc & abc & abc \\\\\\\\ \\ # \\ # \\ # & \\ # 2 \\ # & \\ # 3 \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 1 2 abc abc abc 1 1 . 00 3 . 000 2 - 1 2","title":"Placeholders"},{"location":"usage/03placeholders.html#placeholders","text":"Warning This page is under construction The template placeholders determine where the numbers from the input files are and how they will be displayed. Every table in the template file (if it is to be filled) must appear within a table environment. There can be several tabular environments within the table environment, but only ONE label per table environment. While label names may appear more than once in both the template and input files, only the last instance of the label in the input files will be used. This because of the way the system is set up: The last label in the input file should be the most up to date version of that table. In the template file, repeated labels are filled with the same data. By design, labels are NOT case-sensitive.","title":"Placeholders"},{"location":"usage/03placeholders.html#placeholders_1","text":"The values in the template file are parsed as follows: Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. |###| Get the absolute value of the number. Consider the following examples abc + ### = abc 2309 . 2093 + ### = 2309 . 2093 2309 . 2093 + # 4 # = 2309 . 2093 2309 . 2093 + # 5 # = 2309 . 20930 2309 . 2093 + # 20 # = 2309 . 20930000000000000000 2309 . 2093 + # 3 # = 2309 . 209 2309 . 2093 + # 2 # = 2309 . 21 2309 . 2093 + # 0 # = 2309 2309 . 2093 + # 0 , # = 2 , 309 - 2 . 23 e - 2 + # 2 # = - 0 . 0223 + # 2 # = - 0 . 02 - 2 . 23 e + 10 + # 7 , # = - 22300000000 + # 7 , # = - 22 , 300 , 000 , 000 . 000000 2309 . 2093 + ( # 2 # ) = ( 2309 . 21 ) 2309 . 2093 + # 2 #** = 2309 . 21 ** 2309 . 2093 + ab # 2 # cd = ab2309 . 21 cd . 2093 + # 1 %# = 20 . 9 - 2 . 23 e - 2 + |# 7 #| = - 0 . 0223 + |# 7 #| = 0 . 0223000 . 1309 + #*# = . 0639 + #*# = * . 0139 + #*# = ** . 0013 + #*# = *** Note that there can be ANYTHING around the pattern and the engine will only match the pattern. Further, in LaTeX, the # character must be escaped, so the engine also matches #. Consider: 3234 . 43241 + \\\\ beta Hi \\$ ( \\ # \\ # \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ ## \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # \\ ## ) \\ %* = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( # \\ # \\ # ) \\ % = \\\\ beta Hi \\$ ( 3234 . 43241 ) \\ % 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ ### ) * \\ % = \\\\ beta Hi \\$ ( 3234 . 43241 ) * \\ % 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3 , 234 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , \\ # ) \\ %* = \\\\ beta Hi \\$ ( 3 , 234 ) \\ %* 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , #* = \\\\ beta Hi \\$ ( 3 , 234 * 3234 . 43241 + & \\\\ beta Hi \\$ ( # 0 , \\ #* = \\\\ beta Hi \\$ ( 3 , 234 * 3234 . 43241 + & \\\\ beta Hi \\$ ( \\ # 0 , #* = \\\\ beta Hi \\$ ( 3 , 234 *","title":"Placeholders"},{"location":"usage/03placeholders.html#matrices","text":"","title":"Matrices"},{"location":"usage/03placeholders.html#simple-example","text":"Input: < tab : Test > 1 2 3 2 1 3 3 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 2 3 2 1 3 3 1 2","title":"Simple Example"},{"location":"usage/03placeholders.html#missing-values","text":"Input: < tab : Test > 1 . 3 2 e - 5 1 3 . 023 . - 1 2 3 Template: \\ label { tab : test } ( \\ # \\ # \\ # ) & 2 & \\ # \\ # \\ # & \\\\\\\\ \\ # 3 \\ # & \\ # \\ # \\ # & \\ # 1 \\ # & \\\\\\\\ NA & \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } ( 1 ) 2 3 0 . 000 1 3 . 0 NA - 1 2 3 Important : Missing values in input and template need not line up. Input: < tab : Test > 1 . 3 2 e - 5 . 3 . 023 . - 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & abc \\\\\\\\ abc & \\ # 2 \\ # & \\ # 3 \\ # \\\\\\\\ NA & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 3 abc abc 0 . 00 3 . 023 NA - 1 2","title":"Missing Values"},{"location":"usage/03placeholders.html#text","text":"Input: < tab : Test > 1 1 2 1 1 3 2 - 1 2 Template: \\ label { tab : test } \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ abc & abc & abc \\\\\\\\ \\ # \\ # \\ # & \\ # 2 \\ # & \\ # 3 \\ # \\\\\\\\ \\ # \\ # \\ # & \\ # \\ # \\ # & \\ # \\ # \\ # \\\\\\\\ Output: \\ label { tab : test } 1 1 2 abc abc abc 1 1 . 00 3 . 000 2 - 1 2","title":"Text"},{"location":"usage/04common-issues.html","text":"Common Issues Warning This page is under construction Common Mistakes Missing table label/tag in the input file or in the template file. Mismatch between the length of the template table and corresponding text table. If the template table has more entries to be filled than the text table has entries to fill from, this will cause an error. Use of numerical tags (e.g. #1#) to fill non-numerical data. This will cause an error. Non-numerical data can only be filled using \"###\", as it does not make sense to round or truncate this data. The program currently does not handle trailing comments. If a line doesn't start with a comment, it will replace everything in that line, even if there is a comment halfway through. New lines of the table must be on new lines of the .tex file Error Logging The program indicates When it finds a table environment If it finds a label within that environment If the label matches one in the input file(s) Whether it finds the #(#|\\d+,*)# pattern but no label When it finds the end of the table environment How many substitutions it made in the table When it finds the #(#|\\d+,*)# pattern outside a table environment When it finds more #(#|\\d+,*)# than entries in the corresponding table When it finds an error (and if so it terminates)","title":"Common Issues"},{"location":"usage/04common-issues.html#common-issues","text":"Warning This page is under construction","title":"Common Issues"},{"location":"usage/04common-issues.html#common-mistakes","text":"Missing table label/tag in the input file or in the template file. Mismatch between the length of the template table and corresponding text table. If the template table has more entries to be filled than the text table has entries to fill from, this will cause an error. Use of numerical tags (e.g. #1#) to fill non-numerical data. This will cause an error. Non-numerical data can only be filled using \"###\", as it does not make sense to round or truncate this data. The program currently does not handle trailing comments. If a line doesn't start with a comment, it will replace everything in that line, even if there is a comment halfway through. New lines of the table must be on new lines of the .tex file","title":"Common Mistakes"},{"location":"usage/04common-issues.html#error-logging","text":"The program indicates When it finds a table environment If it finds a label within that environment If the label matches one in the input file(s) Whether it finds the #(#|\\d+,*)# pattern but no label When it finds the end of the table environment How many substitutions it made in the table When it finds the #(#|\\d+,*)# pattern outside a table environment When it finds more #(#|\\d+,*)# than entries in the corresponding table When it finds an error (and if so it terminates)","title":"Error Logging"},{"location":"usage/05advanced-options.html","text":"Advanced Options Warning This page is under construction tablefill can be used both as a command line program and a python module: Command-line use tablefill [ - h ] [ - v ] [ FLAGS ] [ - i [ INPUT [ INPUT ...]]] [ - o OUTPUT ] [ -- pvals [ PVALS [ PVALS ...]]] [ -- stars [ STARS [ STARS ...]]] [ -- xml - tables [ INPUT [ INPUT ...]]] [ - t { auto , lyx , tex }] TEMPLATE Fill tagged tables in LaTeX and LyX files with external text tables positional arguments : TEMPLATE Code template optional arguments : - h , -- help show this help message and exit - v , -- version Show current version - i [ INPUT [ INPUT ...]], -- input [ INPUT [ INPUT ...]] Input files with tables ( default : INPUT_table ) - o OUTPUT , -- output OUTPUT Processed template file ( default : INPUT_filled ) - t { auto , lyx , tex }, -- type { auto , lyx , tex } Template file type ( default : auto ) -- pvals [ PVALS [ PVALS ...]] Significance thresholds -- stars [ STARS [ STARS ...]] Stars for sig thresholds ( enclose each entry in quotes ) -- xml - tables [ INPUT [ INPUT ...]] Files with custom xml combinations . flags : - f , -- force Name input / output automatically - c , -- compile Compile output - b , -- bibtex Run bibtex on . aux file and re - compile - fc , -- fill - comments Fill in commented out placeholders . -- numpy - syntax Numpy syntax for custom XML tables . -- use - floats Force floats when passing objects to custom XML python . -- ignore - xml Ignore XML in template comments . -- verbose Verbose printing ( for debugging ) -- silent Try to say nothing Python use Options are analogous to their command-lien counterparts: from tablefill import tablefill exit , exit_msg = tablefill ( template , # required input , # required output , # required filetype , verbose , silent , pvals , stars , fillc , numpy_syntax , use_floats , ignore_xml , xml_tables )","title":"Advanced Options"},{"location":"usage/05advanced-options.html#advanced-options","text":"Warning This page is under construction tablefill can be used both as a command line program and a python module:","title":"Advanced Options"},{"location":"usage/05advanced-options.html#command-line-use","text":"tablefill [ - h ] [ - v ] [ FLAGS ] [ - i [ INPUT [ INPUT ...]]] [ - o OUTPUT ] [ -- pvals [ PVALS [ PVALS ...]]] [ -- stars [ STARS [ STARS ...]]] [ -- xml - tables [ INPUT [ INPUT ...]]] [ - t { auto , lyx , tex }] TEMPLATE Fill tagged tables in LaTeX and LyX files with external text tables positional arguments : TEMPLATE Code template optional arguments : - h , -- help show this help message and exit - v , -- version Show current version - i [ INPUT [ INPUT ...]], -- input [ INPUT [ INPUT ...]] Input files with tables ( default : INPUT_table ) - o OUTPUT , -- output OUTPUT Processed template file ( default : INPUT_filled ) - t { auto , lyx , tex }, -- type { auto , lyx , tex } Template file type ( default : auto ) -- pvals [ PVALS [ PVALS ...]] Significance thresholds -- stars [ STARS [ STARS ...]] Stars for sig thresholds ( enclose each entry in quotes ) -- xml - tables [ INPUT [ INPUT ...]] Files with custom xml combinations . flags : - f , -- force Name input / output automatically - c , -- compile Compile output - b , -- bibtex Run bibtex on . aux file and re - compile - fc , -- fill - comments Fill in commented out placeholders . -- numpy - syntax Numpy syntax for custom XML tables . -- use - floats Force floats when passing objects to custom XML python . -- ignore - xml Ignore XML in template comments . -- verbose Verbose printing ( for debugging ) -- silent Try to say nothing","title":"Command-line use"},{"location":"usage/05advanced-options.html#python-use","text":"Options are analogous to their command-lien counterparts: from tablefill import tablefill exit , exit_msg = tablefill ( template , # required input , # required output , # required filetype , verbose , silent , pvals , stars , fillc , numpy_syntax , use_floats , ignore_xml , xml_tables )","title":"Python use"},{"location":"usage/06xml-engine.html","text":"XML Engine Warning This page is under construction The following code in the .tex template will be interpreted by tablefill.py (please note I use tag and label interchangeably throughout the documentation): % <tablefill-python tag = 'newtagname' > % tagname[rows1][subentries1], % tagname[rows2][subentries2], % othertagname[rows3][subentries3] % </tablefill-python> % % <tablefill-python tag = 'othernewtagname' type = 'float' > % tagname[row1][subentry1] / tagname[row2][subentry2], % othertagname[rows3][subentries3] % </tablefill-python> The above is parsed as xml and will create 2 new tags: First it creates newtagname with [rows1][subentries1] and [rows2][subentries2] from tagname and [rows3][subentries3] from othertagname . Second it creates othernewtagname with the result of the operation tagname[row1][subentry1] / tagname[row2][subentry2] followed by the entries from othertagname[rows3][subentries3] . Only scalar operations are supported, and the type must be set to float or the parsing will exit with error. The syntax for [rows][sub] is python syntax for nested lists: See here . Note that python uses 0-based indexing and that the combine engine uses the raw matrices (i.e. before missing entries are stripped). Each matrix is parsed as a list of lists, so 1 2 3 [[1, 2, 3], . -1 -2 --> [., -1, -2], . 0 . [., 0, .]] [0] or [-1] --> [., 0, .] [1] or [-2] --> [., -1, -2] [2] or [-3] --> [1, 2, 3] [1:] or [-2:] --> [., 0, .] [1][1:3] or [-2][-2:] --> [-1, -2] It is also possible to specify tables in a separate .xml file and pass it to tablefill (there should be no leading % in this case) via --xml-tables in the command line or xml_tables in a function call.","title":"XML Engine"},{"location":"usage/06xml-engine.html#xml-engine","text":"Warning This page is under construction The following code in the .tex template will be interpreted by tablefill.py (please note I use tag and label interchangeably throughout the documentation): % <tablefill-python tag = 'newtagname' > % tagname[rows1][subentries1], % tagname[rows2][subentries2], % othertagname[rows3][subentries3] % </tablefill-python> % % <tablefill-python tag = 'othernewtagname' type = 'float' > % tagname[row1][subentry1] / tagname[row2][subentry2], % othertagname[rows3][subentries3] % </tablefill-python> The above is parsed as xml and will create 2 new tags: First it creates newtagname with [rows1][subentries1] and [rows2][subentries2] from tagname and [rows3][subentries3] from othertagname . Second it creates othernewtagname with the result of the operation tagname[row1][subentry1] / tagname[row2][subentry2] followed by the entries from othertagname[rows3][subentries3] . Only scalar operations are supported, and the type must be set to float or the parsing will exit with error. The syntax for [rows][sub] is python syntax for nested lists: See here . Note that python uses 0-based indexing and that the combine engine uses the raw matrices (i.e. before missing entries are stripped). Each matrix is parsed as a list of lists, so 1 2 3 [[1, 2, 3], . -1 -2 --> [., -1, -2], . 0 . [., 0, .]] [0] or [-1] --> [., 0, .] [1] or [-2] --> [., -1, -2] [2] or [-3] --> [1, 2, 3] [1:] or [-2:] --> [., 0, .] [1][1:3] or [-2][-2:] --> [-1, -2] It is also possible to specify tables in a separate .xml file and pass it to tablefill (there should be no leading % in this case) via --xml-tables in the command line or xml_tables in a function call.","title":"XML Engine"}]}