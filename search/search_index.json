{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"tablefill Automatically update LaTeX, LyX, and Markdown tables using a placeholder system. Quickstart pip install git+https://github.com/mcaceresb/tablefill tablefill --help Documentation tablefill is a program that uses a generic placeholder system to fill LaTeX, LyX, and Markdown tables using formatted output from any programming language. Getting Started gives a basic example of how the system works, and guides the user through updating a template using Stata-generated input files (this example can be replicated with any programming language, however, not just Stata). The usage section details the input required by tablefill , the format of the placeholders that are allowed, and documents the tablefill usage options. Last, we provide examples of how to generate the type of input required by tablefill in the sample programs page. Background The original idea for this workflow comes from GSLab . The original tablefill in particular was made to automatically update LyX files with Stata output. However, I expanded this system to work with LaTeX and added several features. The workflow is as follows: Create a LaTeX, LyX, or Markdown document using placeholders in your tables. Label or tab each table appropriately. Print a matrix (or any array) to a delimited text file. The output is preceded by the tag of the table you want to fill, and the matrix or array's entries correspond to the placeholders. Run tablefill to update the placeholders in the template document. The original tablefill only worked with LyX and assumed the tables came from Stata (or Matlab). This project initially aimed to extend the system to work with LaTeX, but over time it re-wrote the entire code base and added several features: The input tables can be generated by any program as long as they write missing values as blank, a dot, or NA (the \".\" and \"NA\" are exceptions made for Stata and R). The format is to print a tag on the line prior to the table, <tab:table_label> , and then print a tab-delimited table (typically a matrix, but it can be any flat array and have rows or varying length). For compatibility with scripts using GSLab's tablefill, the script can be run from the command line or imported as a python module. Several soft-warnings and error checks were added. Installation pip install git+https://github.com/mcaceresb/tablefill tablefill --help This was created specifically to run in a server that only had Python 2.6 available. The function should be compatible with Python 2.6, Python 2.7, and Python 3.X without requiring the installation of any additional packages (the --numpy-syntax option is available if the function can successfully run import numpy ; however, numpy is not required for normal use). Features As mentioned above, the original idea for tablefill comes from GSLab . However, this version has enough distinct features to merit calling itself a separate program. These include: Ability to fill LaTeX and Markdown templates There can be several placeholders in one line (however, there must be at most one table line per code line). Labels in LaTeX can be anywhere in the table environment. Placeholders can be either # or \\# (note the former is a special character in LaTeX so while the filled output will compile, the template will not). Can have several matches of the pattern in the same line. LaTeX tables can be filled inside Markdown documents. The user can choose whether or not to fill in placeholders in commented-out lines. Several error and consistency checks Checks inputs are correct (names and type) Checks if input files exist Soft warning when placeholder outside proper environment Soft warning when placeholder in environment with no label Soft warning when placeholder in environment with unmatched label Soft warning when more placeholders than table entries Several new placeholder types: Arbitrary python formatting via #{.*}# (note that in python 2.6 this must be #{0:.*}# ). #*# interprets the input as a p-value and replaces it with significance symbols (default is * 0.1, **0.05, ***0.01 ; however, anything that LaTeX, LyX, or Markdown will compile can be passed). Modifier % reads the input as percentage (multiplies by 100). Modifier || outputs the absolute value of the input. tablefill can be run from the command line directly or imported to a python script. Basic compilation support via the --compile and/or --bibtex flags. XML-based ad-hoc table combination engine. The user can combine arbitrary entries of existing tables in the provided templates to create new tables. This is useful if generating new tables is costly. It is also useful to quote table statistics in a summary elsewhere in the text (the LaTeX engine can parse the placeholders as long as they are in a table environment, which can be regular text). Contributors Kyle Barron has made several additions and improvements to this projects. GSLab 's tablefill . License MIT","title":"Home"},{"location":"index.html#tablefill","text":"Automatically update LaTeX, LyX, and Markdown tables using a placeholder system.","title":"tablefill"},{"location":"index.html#quickstart","text":"pip install git+https://github.com/mcaceresb/tablefill tablefill --help","title":"Quickstart"},{"location":"index.html#documentation","text":"tablefill is a program that uses a generic placeholder system to fill LaTeX, LyX, and Markdown tables using formatted output from any programming language. Getting Started gives a basic example of how the system works, and guides the user through updating a template using Stata-generated input files (this example can be replicated with any programming language, however, not just Stata). The usage section details the input required by tablefill , the format of the placeholders that are allowed, and documents the tablefill usage options. Last, we provide examples of how to generate the type of input required by tablefill in the sample programs page.","title":"Documentation"},{"location":"index.html#background","text":"The original idea for this workflow comes from GSLab . The original tablefill in particular was made to automatically update LyX files with Stata output. However, I expanded this system to work with LaTeX and added several features. The workflow is as follows: Create a LaTeX, LyX, or Markdown document using placeholders in your tables. Label or tab each table appropriately. Print a matrix (or any array) to a delimited text file. The output is preceded by the tag of the table you want to fill, and the matrix or array's entries correspond to the placeholders. Run tablefill to update the placeholders in the template document. The original tablefill only worked with LyX and assumed the tables came from Stata (or Matlab). This project initially aimed to extend the system to work with LaTeX, but over time it re-wrote the entire code base and added several features: The input tables can be generated by any program as long as they write missing values as blank, a dot, or NA (the \".\" and \"NA\" are exceptions made for Stata and R). The format is to print a tag on the line prior to the table, <tab:table_label> , and then print a tab-delimited table (typically a matrix, but it can be any flat array and have rows or varying length). For compatibility with scripts using GSLab's tablefill, the script can be run from the command line or imported as a python module. Several soft-warnings and error checks were added.","title":"Background"},{"location":"index.html#installation","text":"pip install git+https://github.com/mcaceresb/tablefill tablefill --help This was created specifically to run in a server that only had Python 2.6 available. The function should be compatible with Python 2.6, Python 2.7, and Python 3.X without requiring the installation of any additional packages (the --numpy-syntax option is available if the function can successfully run import numpy ; however, numpy is not required for normal use).","title":"Installation"},{"location":"index.html#features","text":"As mentioned above, the original idea for tablefill comes from GSLab . However, this version has enough distinct features to merit calling itself a separate program. These include: Ability to fill LaTeX and Markdown templates There can be several placeholders in one line (however, there must be at most one table line per code line). Labels in LaTeX can be anywhere in the table environment. Placeholders can be either # or \\# (note the former is a special character in LaTeX so while the filled output will compile, the template will not). Can have several matches of the pattern in the same line. LaTeX tables can be filled inside Markdown documents. The user can choose whether or not to fill in placeholders in commented-out lines. Several error and consistency checks Checks inputs are correct (names and type) Checks if input files exist Soft warning when placeholder outside proper environment Soft warning when placeholder in environment with no label Soft warning when placeholder in environment with unmatched label Soft warning when more placeholders than table entries Several new placeholder types: Arbitrary python formatting via #{.*}# (note that in python 2.6 this must be #{0:.*}# ). #*# interprets the input as a p-value and replaces it with significance symbols (default is * 0.1, **0.05, ***0.01 ; however, anything that LaTeX, LyX, or Markdown will compile can be passed). Modifier % reads the input as percentage (multiplies by 100). Modifier || outputs the absolute value of the input. tablefill can be run from the command line directly or imported to a python script. Basic compilation support via the --compile and/or --bibtex flags. XML-based ad-hoc table combination engine. The user can combine arbitrary entries of existing tables in the provided templates to create new tables. This is useful if generating new tables is costly. It is also useful to quote table statistics in a summary elsewhere in the text (the LaTeX engine can parse the placeholders as long as they are in a table environment, which can be regular text).","title":"Features"},{"location":"index.html#contributors","text":"Kyle Barron has made several additions and improvements to this projects. GSLab 's tablefill .","title":"Contributors"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"getting-started.html","text":"Getting Started Note This page illustrates the usage of tablefill with Stata. However, any programming language can produce output to be used by tablefill . See the sample programs section for details. tablefill allows the user to update text and numbers in LaTeX, LyX, and Markdown. Its main purpose is to aid the user in creating reproducible reports that can be automatically updated. Installation To install tablefill , run pip install git+https://github.com/mcaceresb/tablefill You can the use tablefill from the command-line via tablefill -i input1.txt [ input2.txt ... ] -o output.tex template.tex Or directly from python via from tablefill import tablefill tablefill ( input = 'input1.txt input2.txt ...' , output = 'output.tex' , template = 'template.tex' ) If you do not wish to install tablefill system-wide, you can simply download tablefill.py and place it in your project's folder. The above snippet will import it into python correctly; however, the command-line call is would change to: python paht/to/tablefill.py -i input1.txt [ input2.txt ... ] -o output.tex template.tex Overview tablefill replaces named placeholders inside LaTeX, LyX, or Markdown tables. While the initial setup is more complex than, say, estout or tabout , tablefill is much more flexible. The workflow is typically as follows: Create a LaTeX (or LyX or Markdown) document with tables that you want filled with numeric (or text) output. Each table must be labeled and have placeholders where you need output to be replaced. Format the table in any way you see fit; placeholders can be anywhere inside the table. Create a matrix of values that correspond to the table's placeholders. Values will be read in order from the topmost row, left to right. Export that matrix to a text file. The matrix is preceded by a label that must match the label in your LaTeX document. Numeric matrices are most common, but tablefill will also take text input. tablefill replaces the placeholders with the matrix values. The strength of this workflow is its flexibility. The user can format their tables however they see fit, without imposing any restrictions on where the values will be filled, as long as they are inside a labeled table. Optionally, the user can create a file with various mappings to allow multiple Stata matrices to be appended as a single LaTeX table, or different portions of a single matrix to be appended to several tables. This is covered in the XML engine section. Basic Example in LaTeX Template First you need to create a file with a table that you want. This can be anything from summary statistics to regression results to paragraphs that refer to a specifics or text which need to be updated. Consider, for instance, template.tex below: % template.tex \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\label { tab:paragraph } % must match label in input.txt Sample paragraph referring to a number: e.g. $ N = \\# 0 , \\# $ . Or perhaps text: e.g. This is the \\#\\#\\# sample. You can also fill text using python-style formatting: \\# {} \\# . \\end { table } Regular placeholders: \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } Python-style formatting: \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % must match label in input.txt \\begin { tabular }{ p { 4.25cm } c } Outcomes & Coef & (SE) \\\\ Variable 1 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ Variable 2 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ Variable 3 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ \\midrule N & \\# { :,.0f } \\# \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } Placeholders Placeholders are of the form ### or \\#\\#\\# (the latter since LaTeX requires the # character to be escaped), with the middle placeholder varying depending on whether you wish to customize the printing format. The following constructs are available: Placeholder Format Description ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. #|#|# Get the absolute value of the number. #{.*}# Arbitrary python format. Anything that string.format() will accept is allowed. In Python 2.6, you must prepend 0: , that is {0:.+} . Each table contains somewhere in it a label{tab:...} statement. This is required and will be used to identify the input to use to fill in that table. It must match an entry in input.txt ( created below ) or it must match a name provided in the optional mapping file. There must be at most one table line per code line (hence all the \\\\ , but that also makes the table more readable). The LaTeX environment must be a table environment, not tabular. See the LyX and Markdown sections below for details on how to set up tables in those formats. Input In order to fill this template, we need data. Consider this example input file, called input.txt <tab:paragraph> 5708 'tablefill example' 'python formatting' <tab:example> 1 1237.1234 1 2 2 2234.4 3 2.4 3 3.345345 2 2.456 4 2234.4 3 2.4 <tab:anotherExample> -1.25 -1.18 0.1447266 2.756 -0.53 9.964426e-08 1.13 0.57235 0.02417291 5708 (see below for an example of how to create this file directly from Stata). Output To get the filled output, run tablefill -i input.txt -o filled.tex template.tex This produces input.txt : %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % This file was produced by 'tablefill.py' % Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.tex % Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input.txt'] % To make changes, edit the input and template files. % % % DO NOT EDIT THIS FILE DIRECTLY. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\label { tab:paragraph } % must match label in input.txt Sample paragraph referring to a number: e.g. $ N = 5 , 708 $ . Or perhaps text: e.g. This is the 'tablefill example' sample. You can also fill text using python-style formatting: 'python formatting'. \\end { table } Regular placeholders: \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes 1 & 1,237 & 1.0 & (2.00) \\\\ Outcomes 2 & 2,234 & 3.0 & (2.40) \\\\ Outcomes 3 & 3 & 2.0 & (2.46) \\\\ Outcomes 4 & 2,234 & 3.0 & (2.40) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } Python-style formatting: \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % must match label in input.txt \\begin { tabular }{ p { 4.25cm } c } Outcomes & Coef & (SE) \\\\ Variable 1 & -1.2 (-1.18) \\\\ Variable 2 & 2.8 (-0.53)*** \\\\ Variable 3 & 1.1 (0.57)** \\\\ \\midrule N & 5,708 \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document } Explanation The following replacements were made: Placeholder Replacement \\#\\#\\# replaced as is; mainly used for text input \\#0,\\# round to 0 decimal places, add thousands comma-separator \\#1\\# round to 1 decimal places \\#2\\# round to 2 decimal places \\#*\\# Input is a p-value; replaced with significance stars \\#{}\\# Passes input to \"{}\".format() (print as is) \\#{:.1f}\\# Passes input to \"{:.1f}\".format() (round to 1 decimal places) \\#{:,.0f}\\# Passes input to \"{:,.0f}\".format() (thousands comma-separator, round to 0 decimal places) The way tablefill operates is: Per line, the program searches for the start of a table. In LaTeX, this is \\begin{table} . If found, it searches for a label before the the table ends. In LaTeX this is \\label{tab:(.+)} before \\end{table} . If a label is found, it searches the input files for a label a match. Find all occurrences of placeholders (note that in LaTeX, # is a special character, so tablefill will match both # and \\# as part of a placeholder construct; this is so that templates can be compiled before using tablefill to fill in the values). Repeat 3 and 4 until reaching \\end{table} Move on to next table: Repeat 1 to 5 until reaching the end of the document. Exporting Matrices in Stata We provide code snippets in several programming languages to illustrate the format required by tablefill as input. For this example, we will use a Stata program named saveTable . We keep a copy in this repository, and you can install it from Stata by running: local gh_repo https: // raw . githubusercontent . com / mcaceresb / tablefill net install matrix_tools, from( \" `gh_repo' /master/docs/programs'\" ) Now you should be able to run saveTable from any Stata session. As a simple example, we create a random matrix with four rows and three columns: matrix x = ( 1 , 1237.1234 , 1 , 2 ) \\ /// ( 2 , 2234.4 , 3 , 2.4 ) \\ /// ( 3 , 3.345345 , 2 , 2.456 ) ( 4 , 2234.4 , 3 , 2.4 ) saveTable using \"input.txt\" , outmatrix(x) tag( \"<tab:example>\" ) saveTable arguments using : required , provide the filename to write to. OUTMatrix : required , provide the name of the matrix intended for exporting. The capitalization OUTMatrix means that at this command can be abbreviated up to outmat , that is saveTable using \"matrix.txt\" , outm(x) tag( \"<tab:example_matrix>\" ) tag : required , string for tag for outputted matrix. Note that the format is <tab:label> . To append a matrix to the last tag in the file, provide a blank tag. saveTable using \"matrix.txt\" , outm(x) tag( \"<tab:example_matrix>\" ) saveTable using \"matrix.txt\" , outm(y) tag( \" \" ) <tab:example_matrix> entries of x entries of y Format : optional , string for numerical format for outputted data. By default the output format is %21.9f We give the example of a numeric matrix, as this is the most common usage, but as we saw above any text that is appended after the label can be filled by tablefill (entries must be tab-delimited or appear in a separate line). To produce the input.txt file we use earlier, run the following do file : file open fh using \"input.txt\" , write text append file write fh \"<tab:paragraph>\" _n /// _tab \"5708\" _n /// _tab \"'tablefill example'\" _n /// _tab \"'python formatting'\" _n file close fh matrix x = ( 1 , 1237.1234 , 1 , 2 ) \\ /// ( 2 , 2234.4 , 3 , 2.4 ) \\ /// ( 3 , 3.345345 , 2 , 2.456 ) \\ /// ( 4 , 2234.4 , 3 , 2.4 ) matrix y = ( - 1.25 , - 1.18 , 0.1447266 ) \\ /// ( 2.756 , - 0.53 , 9.964426e-08 ) \\ /// ( 1.13 , 0.57235 , 0.02417291 ) \\ /// ( 5708 , ., .) saveTable using \"input.txt\" , outmatrix(x) f( %12.0g ) tag( \"<tab:example>\" ) saveTable using \"input.txt\" , outmatrix(y) f( %12.0g ) tag( \"<tab:anotherExample>\" ) Now you can run tablefill -i input.txt -o filled.tex template.tex Basic Example in Markdown Consider the file template.md <!-- tablefill:start tab:paragraph --> Sample paragraph referring to a number: e.g. $N = #0,#$. Or perhaps text: e.g. This is the ### sample. You can also fill text using python-style formatting: #{}#. <!-- tablefill:end --> <!-- tablefill:start tab:example --> | Outcomes | N | Mean | (Std.) | | ------------ | ---- | ---- | ------ | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | <!-- tablefill:end --> `pandoc` will compile raw LaTeX inside markdown documents, so `tablefill` will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\\\ Variable 1 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ Variable 2 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ Variable 3 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ \\midrule N & \\#{:,.0f}\\# \\\\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document} Using the same input.txt file as above, run tablefill.py -i input.txt -o filled.md template.md This produces filled.md <!-- This file was produced by 'tablefill.py' Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.md Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input.txt'] To make changes, edit the input and template files. DO NOT EDIT THIS FILE DIRECTLY. --> <!-- tablefill:start tab:paragraph --> Sample paragraph referring to a number: e.g. $N = 5,708$. Or perhaps text: e.g. This is the 'tablefill example' sample. You can also fill text using python-style formatting: 'python formatting'. <!-- tablefill:end --> <!-- tablefill:start tab:example --> | Outcomes | N | Mean | (Std.) | | ------------ | ---- | ---- | ------ | | Outcomes 1 | 1,237 | 1.0 | (2.00) | | Outcomes 2 | 2,234 | 3.0 | (2.40) | | Outcomes 3 | 3 | 2.0 | (2.46) | | Outcomes 4 | 2,234 | 3.0 | (2.40) | <!-- tablefill:end --> `pandoc` will compile raw LaTeX inside markdown documents, so `tablefill` will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\\\ Variable 1 & -1.2 (-1.18) \\\\ Variable 2 & 2.8 (-0.53)*** \\\\ Variable 3 & 1.1 (0.57)** \\\\ \\midrule N & 5,708 \\\\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document} Basic Example in LyX Warning This section is under construction Comparison with other methods There are a few programs to do this in Stata. estout is very helpful, but it is mainly designed to work with estimation output and can be hard to customize otherwise. tabout is very promising but somewhat hard to use. Further, both estout and tabout impose a specific process to create the matrix of values that underlies a table. This means that a lot of the formatting must be done directly from Stata, which is not as flexible as tablefill 's approach. Naturally, if the shape and format of the tables that you will be producing will vary a lot and you do not need the flexibility that tablefill affords, then it is probably not the best tool, as it does have steeper setup costs.","title":"Getting Started"},{"location":"getting-started.html#getting-started","text":"Note This page illustrates the usage of tablefill with Stata. However, any programming language can produce output to be used by tablefill . See the sample programs section for details. tablefill allows the user to update text and numbers in LaTeX, LyX, and Markdown. Its main purpose is to aid the user in creating reproducible reports that can be automatically updated.","title":"Getting Started"},{"location":"getting-started.html#installation","text":"To install tablefill , run pip install git+https://github.com/mcaceresb/tablefill You can the use tablefill from the command-line via tablefill -i input1.txt [ input2.txt ... ] -o output.tex template.tex Or directly from python via from tablefill import tablefill tablefill ( input = 'input1.txt input2.txt ...' , output = 'output.tex' , template = 'template.tex' ) If you do not wish to install tablefill system-wide, you can simply download tablefill.py and place it in your project's folder. The above snippet will import it into python correctly; however, the command-line call is would change to: python paht/to/tablefill.py -i input1.txt [ input2.txt ... ] -o output.tex template.tex","title":"Installation"},{"location":"getting-started.html#overview","text":"tablefill replaces named placeholders inside LaTeX, LyX, or Markdown tables. While the initial setup is more complex than, say, estout or tabout , tablefill is much more flexible. The workflow is typically as follows: Create a LaTeX (or LyX or Markdown) document with tables that you want filled with numeric (or text) output. Each table must be labeled and have placeholders where you need output to be replaced. Format the table in any way you see fit; placeholders can be anywhere inside the table. Create a matrix of values that correspond to the table's placeholders. Values will be read in order from the topmost row, left to right. Export that matrix to a text file. The matrix is preceded by a label that must match the label in your LaTeX document. Numeric matrices are most common, but tablefill will also take text input. tablefill replaces the placeholders with the matrix values. The strength of this workflow is its flexibility. The user can format their tables however they see fit, without imposing any restrictions on where the values will be filled, as long as they are inside a labeled table. Optionally, the user can create a file with various mappings to allow multiple Stata matrices to be appended as a single LaTeX table, or different portions of a single matrix to be appended to several tables. This is covered in the XML engine section.","title":"Overview"},{"location":"getting-started.html#basic-example-in-latex","text":"","title":"Basic Example in LaTeX"},{"location":"getting-started.html#template","text":"First you need to create a file with a table that you want. This can be anything from summary statistics to regression results to paragraphs that refer to a specifics or text which need to be updated. Consider, for instance, template.tex below: % template.tex \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\label { tab:paragraph } % must match label in input.txt Sample paragraph referring to a number: e.g. $ N = \\# 0 , \\# $ . Or perhaps text: e.g. This is the \\#\\#\\# sample. You can also fill text using python-style formatting: \\# {} \\# . \\end { table } Regular placeholders: \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ Outcomes \\#\\#\\# & \\# 0, \\# & \\# 1 \\# & ( \\# 2 \\# ) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } Python-style formatting: \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % must match label in input.txt \\begin { tabular }{ p { 4.25cm } c } Outcomes & Coef & (SE) \\\\ Variable 1 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ Variable 2 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ Variable 3 & \\# { :.1f } \\# ( \\# { :.2f } \\# ) \\#*\\# \\\\ \\midrule N & \\# { :,.0f } \\# \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document }","title":"Template"},{"location":"getting-started.html#placeholders","text":"Placeholders are of the form ### or \\#\\#\\# (the latter since LaTeX requires the # character to be escaped), with the middle placeholder varying depending on whether you wish to customize the printing format. The following constructs are available: Placeholder Format Description ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. #|#|# Get the absolute value of the number. #{.*}# Arbitrary python format. Anything that string.format() will accept is allowed. In Python 2.6, you must prepend 0: , that is {0:.+} . Each table contains somewhere in it a label{tab:...} statement. This is required and will be used to identify the input to use to fill in that table. It must match an entry in input.txt ( created below ) or it must match a name provided in the optional mapping file. There must be at most one table line per code line (hence all the \\\\ , but that also makes the table more readable). The LaTeX environment must be a table environment, not tabular. See the LyX and Markdown sections below for details on how to set up tables in those formats.","title":"Placeholders"},{"location":"getting-started.html#input","text":"In order to fill this template, we need data. Consider this example input file, called input.txt <tab:paragraph> 5708 'tablefill example' 'python formatting' <tab:example> 1 1237.1234 1 2 2 2234.4 3 2.4 3 3.345345 2 2.456 4 2234.4 3 2.4 <tab:anotherExample> -1.25 -1.18 0.1447266 2.756 -0.53 9.964426e-08 1.13 0.57235 0.02417291 5708 (see below for an example of how to create this file directly from Stata).","title":"Input"},{"location":"getting-started.html#output","text":"To get the filled output, run tablefill -i input.txt -o filled.tex template.tex This produces input.txt : %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % This file was produced by 'tablefill.py' % Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.tex % Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input.txt'] % To make changes, edit the input and template files. % % % DO NOT EDIT THIS FILE DIRECTLY. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \\documentclass { article } \\usepackage { booktabs } \\begin { document } \\begin { table } \\label { tab:paragraph } % must match label in input.txt Sample paragraph referring to a number: e.g. $ N = 5 , 708 $ . Or perhaps text: e.g. This is the 'tablefill example' sample. You can also fill text using python-style formatting: 'python formatting'. \\end { table } Regular placeholders: \\begin { table } \\caption { Table caption (e.g. summary stats) } \\label { tab:example } % name must match label in input1.txt \\begin { tabular }{ p { 4.25cm } crcc } Outcomes & N & Mean & (Std.) \\\\ Outcomes 1 & 1,237 & 1.0 & (2.00) \\\\ Outcomes 2 & 2,234 & 3.0 & (2.40) \\\\ Outcomes 3 & 3 & 2.0 & (2.46) \\\\ Outcomes 4 & 2,234 & 3.0 & (2.40) \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } Python-style formatting: \\begin { table } \\caption { Table caption (e.g. regression results) } \\label { tab:anotherExample } % must match label in input.txt \\begin { tabular }{ p { 4.25cm } c } Outcomes & Coef & (SE) \\\\ Variable 1 & -1.2 (-1.18) \\\\ Variable 2 & 2.8 (-0.53)*** \\\\ Variable 3 & 1.1 (0.57)** \\\\ \\midrule N & 5,708 \\\\ \\multicolumn { 4 }{ p { 5cm }}{ \\footnotesize Footnotes! } \\end { tabular } \\end { table } \\end { document }","title":"Output"},{"location":"getting-started.html#explanation","text":"The following replacements were made: Placeholder Replacement \\#\\#\\# replaced as is; mainly used for text input \\#0,\\# round to 0 decimal places, add thousands comma-separator \\#1\\# round to 1 decimal places \\#2\\# round to 2 decimal places \\#*\\# Input is a p-value; replaced with significance stars \\#{}\\# Passes input to \"{}\".format() (print as is) \\#{:.1f}\\# Passes input to \"{:.1f}\".format() (round to 1 decimal places) \\#{:,.0f}\\# Passes input to \"{:,.0f}\".format() (thousands comma-separator, round to 0 decimal places) The way tablefill operates is: Per line, the program searches for the start of a table. In LaTeX, this is \\begin{table} . If found, it searches for a label before the the table ends. In LaTeX this is \\label{tab:(.+)} before \\end{table} . If a label is found, it searches the input files for a label a match. Find all occurrences of placeholders (note that in LaTeX, # is a special character, so tablefill will match both # and \\# as part of a placeholder construct; this is so that templates can be compiled before using tablefill to fill in the values). Repeat 3 and 4 until reaching \\end{table} Move on to next table: Repeat 1 to 5 until reaching the end of the document.","title":"Explanation"},{"location":"getting-started.html#exporting-matrices-in-stata","text":"We provide code snippets in several programming languages to illustrate the format required by tablefill as input. For this example, we will use a Stata program named saveTable . We keep a copy in this repository, and you can install it from Stata by running: local gh_repo https: // raw . githubusercontent . com / mcaceresb / tablefill net install matrix_tools, from( \" `gh_repo' /master/docs/programs'\" ) Now you should be able to run saveTable from any Stata session. As a simple example, we create a random matrix with four rows and three columns: matrix x = ( 1 , 1237.1234 , 1 , 2 ) \\ /// ( 2 , 2234.4 , 3 , 2.4 ) \\ /// ( 3 , 3.345345 , 2 , 2.456 ) ( 4 , 2234.4 , 3 , 2.4 ) saveTable using \"input.txt\" , outmatrix(x) tag( \"<tab:example>\" )","title":"Exporting Matrices in Stata"},{"location":"getting-started.html#savetable-arguments","text":"using : required , provide the filename to write to. OUTMatrix : required , provide the name of the matrix intended for exporting. The capitalization OUTMatrix means that at this command can be abbreviated up to outmat , that is saveTable using \"matrix.txt\" , outm(x) tag( \"<tab:example_matrix>\" ) tag : required , string for tag for outputted matrix. Note that the format is <tab:label> . To append a matrix to the last tag in the file, provide a blank tag. saveTable using \"matrix.txt\" , outm(x) tag( \"<tab:example_matrix>\" ) saveTable using \"matrix.txt\" , outm(y) tag( \" \" ) <tab:example_matrix> entries of x entries of y Format : optional , string for numerical format for outputted data. By default the output format is %21.9f We give the example of a numeric matrix, as this is the most common usage, but as we saw above any text that is appended after the label can be filled by tablefill (entries must be tab-delimited or appear in a separate line). To produce the input.txt file we use earlier, run the following do file : file open fh using \"input.txt\" , write text append file write fh \"<tab:paragraph>\" _n /// _tab \"5708\" _n /// _tab \"'tablefill example'\" _n /// _tab \"'python formatting'\" _n file close fh matrix x = ( 1 , 1237.1234 , 1 , 2 ) \\ /// ( 2 , 2234.4 , 3 , 2.4 ) \\ /// ( 3 , 3.345345 , 2 , 2.456 ) \\ /// ( 4 , 2234.4 , 3 , 2.4 ) matrix y = ( - 1.25 , - 1.18 , 0.1447266 ) \\ /// ( 2.756 , - 0.53 , 9.964426e-08 ) \\ /// ( 1.13 , 0.57235 , 0.02417291 ) \\ /// ( 5708 , ., .) saveTable using \"input.txt\" , outmatrix(x) f( %12.0g ) tag( \"<tab:example>\" ) saveTable using \"input.txt\" , outmatrix(y) f( %12.0g ) tag( \"<tab:anotherExample>\" ) Now you can run tablefill -i input.txt -o filled.tex template.tex","title":"saveTable arguments"},{"location":"getting-started.html#basic-example-in-markdown","text":"Consider the file template.md <!-- tablefill:start tab:paragraph --> Sample paragraph referring to a number: e.g. $N = #0,#$. Or perhaps text: e.g. This is the ### sample. You can also fill text using python-style formatting: #{}#. <!-- tablefill:end --> <!-- tablefill:start tab:example --> | Outcomes | N | Mean | (Std.) | | ------------ | ---- | ---- | ------ | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | | Outcomes ### | #0,# | #1,# | (#2,#) | <!-- tablefill:end --> `pandoc` will compile raw LaTeX inside markdown documents, so `tablefill` will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\\\ Variable 1 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ Variable 2 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ Variable 3 & \\#{:.1f}\\# (\\#{:.2f}\\#)\\#*\\# \\\\ \\midrule N & \\#{:,.0f}\\# \\\\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document} Using the same input.txt file as above, run tablefill.py -i input.txt -o filled.md template.md This produces filled.md <!-- This file was produced by 'tablefill.py' Template file: /home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/template.md Input file(s): ['/home/mauricio/Documents/projects/dev/code/archive/2015/tablefill/docs/usage/01basic/input.txt'] To make changes, edit the input and template files. DO NOT EDIT THIS FILE DIRECTLY. --> <!-- tablefill:start tab:paragraph --> Sample paragraph referring to a number: e.g. $N = 5,708$. Or perhaps text: e.g. This is the 'tablefill example' sample. You can also fill text using python-style formatting: 'python formatting'. <!-- tablefill:end --> <!-- tablefill:start tab:example --> | Outcomes | N | Mean | (Std.) | | ------------ | ---- | ---- | ------ | | Outcomes 1 | 1,237 | 1.0 | (2.00) | | Outcomes 2 | 2,234 | 3.0 | (2.40) | | Outcomes 3 | 3 | 2.0 | (2.46) | | Outcomes 4 | 2,234 | 3.0 | (2.40) | <!-- tablefill:end --> `pandoc` will compile raw LaTeX inside markdown documents, so `tablefill` will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\\\ Variable 1 & -1.2 (-1.18) \\\\ Variable 2 & 2.8 (-0.53)*** \\\\ Variable 3 & 1.1 (0.57)** \\\\ \\midrule N & 5,708 \\\\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document}","title":"Basic Example in Markdown"},{"location":"getting-started.html#basic-example-in-lyx","text":"Warning This section is under construction","title":"Basic Example in LyX"},{"location":"getting-started.html#comparison-with-other-methods","text":"There are a few programs to do this in Stata. estout is very helpful, but it is mainly designed to work with estimation output and can be hard to customize otherwise. tabout is very promising but somewhat hard to use. Further, both estout and tabout impose a specific process to create the matrix of values that underlies a table. This means that a lot of the formatting must be done directly from Stata, which is not as flexible as tablefill 's approach. Naturally, if the shape and format of the tables that you will be producing will vary a lot and you do not need the flexibility that tablefill affords, then it is probably not the best tool, as it does have steeper setup costs.","title":"Comparison with other methods"},{"location":"sample-programs.html","text":"Sample Programs Here we illustrate how to export a matrix into the preferred format of tablefill in several programming languages. R Download script saveTable.R saveTable <- function ( outfile , tag , outmatrix ) { cat ( tag , sep = \"\\n\" , file = outfile , append = TRUE ) write.table ( outmatrix , file = outfile , sep = \"\\t\" , append = TRUE , quote = FALSE , col.names = FALSE , row.names = FALSE ) } saveTable ( \"test.txt\" , \"<tab:testR1>\" , matrix ( 1 : 4 , 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testR2>\" , matrix ( runif ( 4 ), 2 , 2 )) Stata Download script saveTable.ado capture program drop saveTable program saveTable version 13 syntax using / , tag(str) OUTMatrix(name) [fmt(str)] mata : saveTable() end capture mata : mata drop saveTable() mata : void function saveTable() { real scalar i, j, fh real matrix outmatrix outmatrix = st_matrix(st_local( \"outmatrix\" )) fmt = st_local( \"fmt\" ) if ( fmt == \"\" ) { fmt = \"%21.9f\" } fmt = \"\\t\" + fmt fh = fopen(st_local( \"using\" ), \"a\" ) fwrite(fh, sprintf( \"%s\\n\" , st_local( \"tag\" ))) for (i = 1 ; i <= rows(outmatrix); i ++ ) { for (j = 1 ; j <= cols(outmatrix); j ++ ) { fwrite(fh, sprintf(fmt, outmatrix[i, j])) } fwrite(fh, sprintf( \"\\n\" )) } fclose(fh) } end matrix test = ( 1 , 2 \\ 3 , 4 ) saveTable using \"test.txt\" , tag( \"<tab:testStata1>\" ) outmatrix(test) mata : st_matrix( \"test\" , runiform ( 2 , 2 )) saveTable using \"test.txt\" , tag( \"<tab:testStata2>\" ) outmat(test) Python Download script saveTable.py from os import linesep import numpy as np def saveTable ( outfile , tag , outmatrix ): with open ( outfile , \"a\" ) as fh : fh . write ( tag ) fh . write ( linesep ) np . savetxt ( fh , outmatrix , delimiter = ' \\t ' ) saveTable ( \"test.txt\" , \"<tab:testPython1>\" , np . arange ( 4 ) . reshape ( 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testPython2>\" , np . random . uniform ( size = ( 2 , 2 ))) Julia Download script saveTable.jl using DelimitedFiles function saveTable ( outfile , tag , outmatrix ) open ( outfile , \"a\" ) do file write ( file , \" $ ( tag ) \\n \" ) writedlm ( file , outmatrix , \" \\t \" ) end end saveTable ( \"test.txt\" , \"<tab:testJulia1>\" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \"test.txt\" , \"<tab:testJulia2>\" , rand ( 2 , 2 )) Matlab Save saveTable.m with function saveTable ( outfile, tag, outmatrix ) fh = fopen ( outfile , \" a \" ); fprintf ( fh , '%s\\n' , tag ); fclose ( fh ); dlmwrite ( outfile , outmatrix , '-append' , 'delimiter' , '\\t' ); end Then run saveTable ( \" test . txt \" , \" < tab : testMatlab1 > \" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \" test . txt \" , \" < tab : testMatlab2 > \" , rand ( 2 , 2 ))","title":"Sample Programs"},{"location":"sample-programs.html#sample-programs","text":"Here we illustrate how to export a matrix into the preferred format of tablefill in several programming languages.","title":"Sample Programs"},{"location":"sample-programs.html#r","text":"Download script saveTable.R saveTable <- function ( outfile , tag , outmatrix ) { cat ( tag , sep = \"\\n\" , file = outfile , append = TRUE ) write.table ( outmatrix , file = outfile , sep = \"\\t\" , append = TRUE , quote = FALSE , col.names = FALSE , row.names = FALSE ) } saveTable ( \"test.txt\" , \"<tab:testR1>\" , matrix ( 1 : 4 , 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testR2>\" , matrix ( runif ( 4 ), 2 , 2 ))","title":"R"},{"location":"sample-programs.html#stata","text":"Download script saveTable.ado capture program drop saveTable program saveTable version 13 syntax using / , tag(str) OUTMatrix(name) [fmt(str)] mata : saveTable() end capture mata : mata drop saveTable() mata : void function saveTable() { real scalar i, j, fh real matrix outmatrix outmatrix = st_matrix(st_local( \"outmatrix\" )) fmt = st_local( \"fmt\" ) if ( fmt == \"\" ) { fmt = \"%21.9f\" } fmt = \"\\t\" + fmt fh = fopen(st_local( \"using\" ), \"a\" ) fwrite(fh, sprintf( \"%s\\n\" , st_local( \"tag\" ))) for (i = 1 ; i <= rows(outmatrix); i ++ ) { for (j = 1 ; j <= cols(outmatrix); j ++ ) { fwrite(fh, sprintf(fmt, outmatrix[i, j])) } fwrite(fh, sprintf( \"\\n\" )) } fclose(fh) } end matrix test = ( 1 , 2 \\ 3 , 4 ) saveTable using \"test.txt\" , tag( \"<tab:testStata1>\" ) outmatrix(test) mata : st_matrix( \"test\" , runiform ( 2 , 2 )) saveTable using \"test.txt\" , tag( \"<tab:testStata2>\" ) outmat(test)","title":"Stata"},{"location":"sample-programs.html#python","text":"Download script saveTable.py from os import linesep import numpy as np def saveTable ( outfile , tag , outmatrix ): with open ( outfile , \"a\" ) as fh : fh . write ( tag ) fh . write ( linesep ) np . savetxt ( fh , outmatrix , delimiter = ' \\t ' ) saveTable ( \"test.txt\" , \"<tab:testPython1>\" , np . arange ( 4 ) . reshape ( 2 , 2 )) saveTable ( \"test.txt\" , \"<tab:testPython2>\" , np . random . uniform ( size = ( 2 , 2 )))","title":"Python"},{"location":"sample-programs.html#julia","text":"Download script saveTable.jl using DelimitedFiles function saveTable ( outfile , tag , outmatrix ) open ( outfile , \"a\" ) do file write ( file , \" $ ( tag ) \\n \" ) writedlm ( file , outmatrix , \" \\t \" ) end end saveTable ( \"test.txt\" , \"<tab:testJulia1>\" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \"test.txt\" , \"<tab:testJulia2>\" , rand ( 2 , 2 ))","title":"Julia"},{"location":"sample-programs.html#matlab","text":"Save saveTable.m with function saveTable ( outfile, tag, outmatrix ) fh = fopen ( outfile , \" a \" ); fprintf ( fh , '%s\\n' , tag ); fclose ( fh ); dlmwrite ( outfile , outmatrix , '-append' , 'delimiter' , '\\t' ); end Then run saveTable ( \" test . txt \" , \" < tab : testMatlab1 > \" , [[ 1 2 ]; [ 3 4 ]]) saveTable ( \" test . txt \" , \" < tab : testMatlab2 > \" , rand ( 2 , 2 ))","title":"Matlab"},{"location":"usage/02matrix-input.html","text":"Matrix Shapes Warning This page is under construction Note This section was adapted from the readme for the original tablefill.py Input files must be tab-delimited rows of numbers or characters, preceded by <label> . The numbers can be arbitrarily long, can be negative, and can also be in scientific notation. <tab:Test> 1 2 3 2 3 1 3 1 2 The rows do not need to be of equal length. <tab:FunnyMat> 1 2 3 23 2 2 3 3 1 2 2 1 Completely blank (no tab) lines are ignored. If a \"cell\" is merely \".\", \"[space]\", or \"NA\" then it is treated as missing. That is, in the program: <tab:Test> 1 2 3 2 . 1 3 3 1 2 is equivalent to: <tab:Test> 1 2 3 2 1 3 3 1 2 This feature is useful as several languages outputs missing values as NA, blank, or \".\". Last, tablefill understands scientific notation of the form: [numbers].[numbers]e(+/-)[numbers] <tab:TestScientific> 23.2389e+23 -2.23e-2 -0.922e+3","title":"Matrix Input"},{"location":"usage/02matrix-input.html#matrix-shapes","text":"Warning This page is under construction Note This section was adapted from the readme for the original tablefill.py Input files must be tab-delimited rows of numbers or characters, preceded by <label> . The numbers can be arbitrarily long, can be negative, and can also be in scientific notation. <tab:Test> 1 2 3 2 3 1 3 1 2 The rows do not need to be of equal length. <tab:FunnyMat> 1 2 3 23 2 2 3 3 1 2 2 1 Completely blank (no tab) lines are ignored. If a \"cell\" is merely \".\", \"[space]\", or \"NA\" then it is treated as missing. That is, in the program: <tab:Test> 1 2 3 2 . 1 3 3 1 2 is equivalent to: <tab:Test> 1 2 3 2 1 3 3 1 2 This feature is useful as several languages outputs missing values as NA, blank, or \".\". Last, tablefill understands scientific notation of the form: [numbers].[numbers]e(+/-)[numbers] <tab:TestScientific> 23.2389e+23 -2.23e-2 -0.922e+3","title":"Matrix Shapes"},{"location":"usage/03placeholders.html","text":"Placeholders Warning This page is under construction Note This section was adapted from the readme for the original tablefill.py The template placeholders determine where the numbers from the input files are and how they will be displayed. Every table in the template file (if it is to be filled) must appear within a table environment. There can be several tabular environments within the table environment, but only ONE label per table environment. While label names may appear more than once in both the template and input files, only the last instance of the label in the input files will be used. This because of the way the system is set up: The last label in the input file should be the most up to date version of that table. In the template file, repeated labels are filled with the same data. By design, labels are NOT case-sensitive. Placeholders The values in the template file are parsed as follows: Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. #|#|# Get the absolute value of the number. #{.*}# Arbitrary python format. Anything that string.format() will accept is allowed. In Python 2.6, you must prepend 0: , that is {0:.+} . Consider the following examples abc + ### = abc 2309.2093 + ### = 2309.2093 2309.2093 + #4# = 2309.2093 2309.2093 + #5# = 2309.20930 2309.2093 + #20# = 2309.20930000000000000000 2309.2093 + #3# = 2309.209 2309.2093 + #2# = 2309.21 2309.2093 + #0# = 2309 2309.2093 + #0,# = 2,309 -2.23e-2 + #2# = -0.0223 + #2# = -0.02 -2.23e+10 + #7,# = -22300000000 + #7,# = -22,300,000,000.000000 2309.2093 + (#2#) = (2309.21) 2309.2093 + #2#** = 2309.21** 2309.2093 + ab#2#cd = ab2309.21cd .2093 + #1%# = 20.9 -2.23e-2 + |#7#| = -0.0223 + |#7#| = 0.0223000 .1309 + #*# = .0639 + #*# = * .0139 + #*# = ** .0013 + #*# = *** Note that there can be ANYTHING around the pattern and the engine will only match the pattern. Further, in LaTeX, the # character must be escaped, so the engine also matches #. Consider: 3234.43241 + \\\\beta Hi \\$(\\#\\#\\#)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(\\##\\#)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#\\##)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(#\\#\\#)\\% = \\\\beta Hi \\$(3234.43241)\\% 3234.43241 + & \\\\beta Hi \\$(\\###)*\\% = \\\\beta Hi \\$(3234.43241)*\\% 3234.43241 + & \\\\beta Hi \\$(\\#0,\\#)\\%* = \\\\beta Hi \\$(3,234)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#0,\\#)\\%* = \\\\beta Hi \\$(3,234)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#0,#* = \\\\beta Hi \\$(3,234* 3234.43241 + & \\\\beta Hi \\$(#0,\\#* = \\\\beta Hi \\$(3,234* 3234.43241 + & \\\\beta Hi \\$(\\#0,#* = \\\\beta Hi \\$(3,234* Matrices Simple Example Input: <tab:Test> 1 2 3 2 1 3 3 1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 2 3 2 1 3 3 1 2 Missing Values Input: <tab:Test> 1 . 3 2e-5 1 3.023 . -1 2 3 Template: \\label{tab:test} (\\#\\#\\#) & 2 & \\#\\#\\# & \\\\\\\\ \\#3\\# & \\#\\#\\# & \\#1\\# & \\\\\\\\ NA & \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} (1) 2 3 0.000 1 3.0 NA -1 2 3 Important : Missing values in input and template need not line up. Input: <tab:Test> 1 . 3 2e-5 . 3.023 . -1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & abc \\\\\\\\ abc & \\#2\\# & \\#3\\# \\\\\\\\ NA & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 3 abc abc 0.00 3.023 NA -1 2 Text Input: <tab:Test> 1 1 2 1 1 3 2 -1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ abc & abc & abc \\\\\\\\ \\#\\#\\# & \\#2\\# & \\#3\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 1 2 abc abc abc 1 1.00 3.000 2 -1 2","title":"Placeholders"},{"location":"usage/03placeholders.html#placeholders","text":"Warning This page is under construction Note This section was adapted from the readme for the original tablefill.py The template placeholders determine where the numbers from the input files are and how they will be displayed. Every table in the template file (if it is to be filled) must appear within a table environment. There can be several tabular environments within the table environment, but only ONE label per table environment. While label names may appear more than once in both the template and input files, only the last instance of the label in the input files will be used. This because of the way the system is set up: The last label in the input file should be the most up to date version of that table. In the template file, repeated labels are filled with the same data. By design, labels are NOT case-sensitive.","title":"Placeholders"},{"location":"usage/03placeholders.html#placeholders_1","text":"The values in the template file are parsed as follows: Placeholder Format ### Replace as is; input can be text (all other placeholders require numbers). #\\d+# Round to \\d+ digits. #\\d+,# Round to \\d+ digits; add thousands comma separator. #*# Interpret input as p-value and replce with a star corresponding so significance. Detault is * 0.1, **0.05, ***0.01 . #\\d+%# Round to \\d+ digits; interpret as percentage. #|#|# Get the absolute value of the number. #{.*}# Arbitrary python format. Anything that string.format() will accept is allowed. In Python 2.6, you must prepend 0: , that is {0:.+} . Consider the following examples abc + ### = abc 2309.2093 + ### = 2309.2093 2309.2093 + #4# = 2309.2093 2309.2093 + #5# = 2309.20930 2309.2093 + #20# = 2309.20930000000000000000 2309.2093 + #3# = 2309.209 2309.2093 + #2# = 2309.21 2309.2093 + #0# = 2309 2309.2093 + #0,# = 2,309 -2.23e-2 + #2# = -0.0223 + #2# = -0.02 -2.23e+10 + #7,# = -22300000000 + #7,# = -22,300,000,000.000000 2309.2093 + (#2#) = (2309.21) 2309.2093 + #2#** = 2309.21** 2309.2093 + ab#2#cd = ab2309.21cd .2093 + #1%# = 20.9 -2.23e-2 + |#7#| = -0.0223 + |#7#| = 0.0223000 .1309 + #*# = .0639 + #*# = * .0139 + #*# = ** .0013 + #*# = *** Note that there can be ANYTHING around the pattern and the engine will only match the pattern. Further, in LaTeX, the # character must be escaped, so the engine also matches #. Consider: 3234.43241 + \\\\beta Hi \\$(\\#\\#\\#)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(\\##\\#)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#\\##)\\%* = \\\\beta Hi \\$(3234.43241)\\%* 3234.43241 + & \\\\beta Hi \\$(#\\#\\#)\\% = \\\\beta Hi \\$(3234.43241)\\% 3234.43241 + & \\\\beta Hi \\$(\\###)*\\% = \\\\beta Hi \\$(3234.43241)*\\% 3234.43241 + & \\\\beta Hi \\$(\\#0,\\#)\\%* = \\\\beta Hi \\$(3,234)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#0,\\#)\\%* = \\\\beta Hi \\$(3,234)\\%* 3234.43241 + & \\\\beta Hi \\$(\\#0,#* = \\\\beta Hi \\$(3,234* 3234.43241 + & \\\\beta Hi \\$(#0,\\#* = \\\\beta Hi \\$(3,234* 3234.43241 + & \\\\beta Hi \\$(\\#0,#* = \\\\beta Hi \\$(3,234*","title":"Placeholders"},{"location":"usage/03placeholders.html#matrices","text":"","title":"Matrices"},{"location":"usage/03placeholders.html#simple-example","text":"Input: <tab:Test> 1 2 3 2 1 3 3 1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 2 3 2 1 3 3 1 2","title":"Simple Example"},{"location":"usage/03placeholders.html#missing-values","text":"Input: <tab:Test> 1 . 3 2e-5 1 3.023 . -1 2 3 Template: \\label{tab:test} (\\#\\#\\#) & 2 & \\#\\#\\# & \\\\\\\\ \\#3\\# & \\#\\#\\# & \\#1\\# & \\\\\\\\ NA & \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} (1) 2 3 0.000 1 3.0 NA -1 2 3 Important : Missing values in input and template need not line up. Input: <tab:Test> 1 . 3 2e-5 . 3.023 . -1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & abc \\\\\\\\ abc & \\#2\\# & \\#3\\# \\\\\\\\ NA & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 3 abc abc 0.00 3.023 NA -1 2","title":"Missing Values"},{"location":"usage/03placeholders.html#text","text":"Input: <tab:Test> 1 1 2 1 1 3 2 -1 2 Template: \\label{tab:test} \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ abc & abc & abc \\\\\\\\ \\#\\#\\# & \\#2\\# & \\#3\\# \\\\\\\\ \\#\\#\\# & \\#\\#\\# & \\#\\#\\# \\\\\\\\ Output: \\label{tab:test} 1 1 2 abc abc abc 1 1.00 3.000 2 -1 2","title":"Text"},{"location":"usage/04common-issues.html","text":"Common Issues Warning This page is under construction Error Logging tablefill tries to be informative when the template and input do not line up as expected. Therefore when it finds a table environment it checks: If it finds a label within that environment If the label matches one in the input file(s) Whether it finds the #(#|\\d+,*)# pattern but no label When it finds the end of the table environment How many substitutions it made in the table When there are more #(#|\\d+,*)# than entries in the corresponding input matrix. When it finds the #(#|\\d+,*)# pattern outside a table environment If the user forgets to include a label/tag or if there is a mismatch between the number of placeholders, tablefill say so and note where to fix the issue. Notes Non-numerical data can only be filled using \"###\"; all other placeholders require numeric input. The program currently does not handle trailing comments. If a line doesn't start with a comment, it will replace everything in that line, even if there is a comment halfway through. New lines of the table must be on new lines of the .tex file","title":"Common Issues"},{"location":"usage/04common-issues.html#common-issues","text":"Warning This page is under construction","title":"Common Issues"},{"location":"usage/04common-issues.html#error-logging","text":"tablefill tries to be informative when the template and input do not line up as expected. Therefore when it finds a table environment it checks: If it finds a label within that environment If the label matches one in the input file(s) Whether it finds the #(#|\\d+,*)# pattern but no label When it finds the end of the table environment How many substitutions it made in the table When there are more #(#|\\d+,*)# than entries in the corresponding input matrix. When it finds the #(#|\\d+,*)# pattern outside a table environment If the user forgets to include a label/tag or if there is a mismatch between the number of placeholders, tablefill say so and note where to fix the issue.","title":"Error Logging"},{"location":"usage/04common-issues.html#notes","text":"Non-numerical data can only be filled using \"###\"; all other placeholders require numeric input. The program currently does not handle trailing comments. If a line doesn't start with a comment, it will replace everything in that line, even if there is a comment halfway through. New lines of the table must be on new lines of the .tex file","title":"Notes"},{"location":"usage/05advanced-options.html","text":"Advanced Options Warning This page is under construction tablefill can be used both as a command line program and a python module: Command-line use tablefill [-h] [-v] [FLAGS] [-i [INPUT [INPUT ...]]] [-o OUTPUT] [--pvals [PVALS [PVALS ...]]] [--stars [STARS [STARS ...]]] [--xml-tables [INPUT [INPUT ...]]] [-t {auto,lyx,tex}] TEMPLATE positional arguments: TEMPLATE Code template optional arguments: -h, --help show this help message and exit -v, --version Show current version -i [INPUT [INPUT ...]], --input [INPUT [INPUT ...]] Input files with tables (default: TEMPLATE_table) -o OUTPUT, --output OUTPUT Processed template file (default: TEMPLATE_filled) -t {auto,lyx,tex}, --type {auto,lyx,tex} Template file type (default: auto) --pvals [PVALS [PVALS ...]] Significance thresholds --stars [STARS [STARS ...]] Stars for sig thresholds (enclose each entry in quotes) --xml-tables [INPUT [INPUT ...]] Files with custom xml combinations. flags: -f, --force Name input/output automatically -c, --compile Compile output -b, --bibtex Run bibtex on .aux file and re-compile -fc, --fill-comments Fill in commented out placeholders. --numpy-syntax Numpy syntax for custom XML tables. --use-floats Force floats when passing objects to custom XML python. --ignore-xml Ignore XML in template comments. --verbose Verbose printing (for debugging) --silent Try to say nothing Python use Options are analogous to their command-line counterparts: from tablefill import tablefill exit , exit_msg = tablefill ( template , # required input , # required output , # required filetype , # default: True verbose , # default: 'auto' silent , # default: [0.1, 0.05, 0.01] pvals , # default: ['*', '**', '***'] stars , # default: False fillc , # default: False numpy_syntax , # default: False use_floats , # default: False ignore_xml , # default: False xml_tables ) # default: None Required Input template : str Name of user-written document to use as basis for update input : str Space-separated list of files with tables to be used in update. output : str Filled template to be produced. Optional Input verbose : bool print a lot of info silent : bool try to print nothing at all filetype : str auto, lyx, or tex pvals : list p-value thresholds stars : list symbols to replace p-values with fillc : bool whether to fill in commented out lines xml_tables : str or list file or list of files with XML combination tables numpy_syntax : bool use numpy syntax for XML engine use_floats : bool force floats when passing arguments to XML engine ignore_xml : bool whether to ignore XML in commented out lines Output exit : str One of SUCCESS, WARNING, ERROR exit_msg : str Details on the exit status Example exit, exit_msg = tablefill(template = 'template_file', input = 'input_file(s)', output = 'output_file')","title":"Advanced Options"},{"location":"usage/05advanced-options.html#advanced-options","text":"Warning This page is under construction tablefill can be used both as a command line program and a python module:","title":"Advanced Options"},{"location":"usage/05advanced-options.html#command-line-use","text":"tablefill [-h] [-v] [FLAGS] [-i [INPUT [INPUT ...]]] [-o OUTPUT] [--pvals [PVALS [PVALS ...]]] [--stars [STARS [STARS ...]]] [--xml-tables [INPUT [INPUT ...]]] [-t {auto,lyx,tex}] TEMPLATE positional arguments: TEMPLATE Code template optional arguments: -h, --help show this help message and exit -v, --version Show current version -i [INPUT [INPUT ...]], --input [INPUT [INPUT ...]] Input files with tables (default: TEMPLATE_table) -o OUTPUT, --output OUTPUT Processed template file (default: TEMPLATE_filled) -t {auto,lyx,tex}, --type {auto,lyx,tex} Template file type (default: auto) --pvals [PVALS [PVALS ...]] Significance thresholds --stars [STARS [STARS ...]] Stars for sig thresholds (enclose each entry in quotes) --xml-tables [INPUT [INPUT ...]] Files with custom xml combinations. flags: -f, --force Name input/output automatically -c, --compile Compile output -b, --bibtex Run bibtex on .aux file and re-compile -fc, --fill-comments Fill in commented out placeholders. --numpy-syntax Numpy syntax for custom XML tables. --use-floats Force floats when passing objects to custom XML python. --ignore-xml Ignore XML in template comments. --verbose Verbose printing (for debugging) --silent Try to say nothing","title":"Command-line use"},{"location":"usage/05advanced-options.html#python-use","text":"Options are analogous to their command-line counterparts: from tablefill import tablefill exit , exit_msg = tablefill ( template , # required input , # required output , # required filetype , # default: True verbose , # default: 'auto' silent , # default: [0.1, 0.05, 0.01] pvals , # default: ['*', '**', '***'] stars , # default: False fillc , # default: False numpy_syntax , # default: False use_floats , # default: False ignore_xml , # default: False xml_tables ) # default: None","title":"Python use"},{"location":"usage/05advanced-options.html#required-input","text":"template : str Name of user-written document to use as basis for update input : str Space-separated list of files with tables to be used in update. output : str Filled template to be produced.","title":"Required Input"},{"location":"usage/05advanced-options.html#optional-input","text":"verbose : bool print a lot of info silent : bool try to print nothing at all filetype : str auto, lyx, or tex pvals : list p-value thresholds stars : list symbols to replace p-values with fillc : bool whether to fill in commented out lines xml_tables : str or list file or list of files with XML combination tables numpy_syntax : bool use numpy syntax for XML engine use_floats : bool force floats when passing arguments to XML engine ignore_xml : bool whether to ignore XML in commented out lines","title":"Optional Input"},{"location":"usage/05advanced-options.html#output","text":"exit : str One of SUCCESS, WARNING, ERROR exit_msg : str Details on the exit status","title":"Output"},{"location":"usage/05advanced-options.html#example","text":"exit, exit_msg = tablefill(template = 'template_file', input = 'input_file(s)', output = 'output_file')","title":"Example"},{"location":"usage/06xml-engine.html","text":"XML Engine Warning This page is under construction The following code in the .tex template will be interpreted by tablefill.py (please note I use tag and label interchangeably throughout the documentation): % <tablefill-python tag = 'newtagname' > % tagname[rows1][subentries1], % tagname[rows2][subentries2], % othertagname[rows3][subentries3] % </tablefill-python> % % <tablefill-python tag = 'othernewtagname' type = 'float' > % tagname[row1][subentry1] / tagname[row2][subentry2], % othertagname[rows3][subentries3] % </tablefill-python> The above is parsed as xml and will create 2 new tags: First it creates newtagname with [rows1][subentries1] and [rows2][subentries2] from tagname and [rows3][subentries3] from othertagname . Second it creates othernewtagname with the result of the operation tagname[row1][subentry1] / tagname[row2][subentry2] followed by the entries from othertagname[rows3][subentries3] . Only scalar operations are supported, and the type must be set to float or the parsing will exit with error. The syntax for [rows][sub] is python syntax for nested lists: See here . Note that python uses 0-based indexing and that the combine engine uses the raw matrices (i.e. before missing entries are stripped). Each matrix is parsed as a list of lists, so 1 2 3 [[1, 2, 3], . -1 -2 --> [., -1, -2], . 0 . [., 0, .]] [0] or [-1] --> [., 0, .] [1] or [-2] --> [., -1, -2] [2] or [-3] --> [1, 2, 3] [1:] or [-2:] --> [., 0, .] [1][1:3] or [-2][-2:] --> [-1, -2] It is also possible to specify tables in a separate .xml file and pass it to tablefill (there should be no leading % in this case) via --xml-tables in the command line or xml_tables in a function call.","title":"XML Engine"},{"location":"usage/06xml-engine.html#xml-engine","text":"Warning This page is under construction The following code in the .tex template will be interpreted by tablefill.py (please note I use tag and label interchangeably throughout the documentation): % <tablefill-python tag = 'newtagname' > % tagname[rows1][subentries1], % tagname[rows2][subentries2], % othertagname[rows3][subentries3] % </tablefill-python> % % <tablefill-python tag = 'othernewtagname' type = 'float' > % tagname[row1][subentry1] / tagname[row2][subentry2], % othertagname[rows3][subentries3] % </tablefill-python> The above is parsed as xml and will create 2 new tags: First it creates newtagname with [rows1][subentries1] and [rows2][subentries2] from tagname and [rows3][subentries3] from othertagname . Second it creates othernewtagname with the result of the operation tagname[row1][subentry1] / tagname[row2][subentry2] followed by the entries from othertagname[rows3][subentries3] . Only scalar operations are supported, and the type must be set to float or the parsing will exit with error. The syntax for [rows][sub] is python syntax for nested lists: See here . Note that python uses 0-based indexing and that the combine engine uses the raw matrices (i.e. before missing entries are stripped). Each matrix is parsed as a list of lists, so 1 2 3 [[1, 2, 3], . -1 -2 --> [., -1, -2], . 0 . [., 0, .]] [0] or [-1] --> [., 0, .] [1] or [-2] --> [., -1, -2] [2] or [-3] --> [1, 2, 3] [1:] or [-2:] --> [., 0, .] [1][1:3] or [-2][-2:] --> [-1, -2] It is also possible to specify tables in a separate .xml file and pass it to tablefill (there should be no leading % in this case) via --xml-tables in the command line or xml_tables in a function call.","title":"XML Engine"},{"location":"usage/01basic/filled.html","text":"Sample paragraph referring to a number: e.g. $N = 5,708$. Or perhaps text: e.g. This is the 'tablefill example' sample. You can also fill text using python-style formatting: 'python formatting'. Outcomes N Mean (Std.) Outcomes 1 1,237 1.0 (2.00) Outcomes 2 2,234 3.0 (2.40) Outcomes 3 3 2.0 (2.46) Outcomes 4 2,234 3.0 (2.40) pandoc will compile raw LaTeX inside markdown documents, so tablefill will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\ Variable 1 & -1.2 (-1.18) \\ Variable 2 & 2.8 (-0.53) * \\ Variable 3 & 1.1 (0.57) \\ \\midrule N & 5,708 \\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document}","title":"Filled"},{"location":"usage/01basic/template.html","text":"Sample paragraph referring to a number: e.g. $N = #0,#$. Or perhaps text: e.g. This is the ### sample. You can also fill text using python-style formatting: #{}#. Outcomes N Mean (Std.) Outcomes ### #0,# #1,# (#2,#) Outcomes ### #0,# #1,# (#2,#) Outcomes ### #0,# #1,# (#2,#) Outcomes ### #0,# #1,# (#2,#) pandoc will compile raw LaTeX inside markdown documents, so tablefill will also replace placeholders in LaTeX tables inside markdown files: \\begin{table} \\caption{Table caption (e.g. regression results)} \\label{tab:anotherExample} \\begin{tabular}{p{4.25cm}c} Outcomes & Coef & (SE) \\ Variable 1 & #{:.1f}# (#{:.2f}#)# # \\ Variable 2 & #{:.1f}# (#{:.2f}#)# # \\ Variable 3 & #{:.1f}# (#{:.2f}#)#*# \\ \\midrule N & #{:,.0f}# \\ \\multicolumn{4}{p{5cm}}{\\footnotesize Footnotes!} \\end{tabular} \\end{table} \\end{document}","title":"Template"}]}